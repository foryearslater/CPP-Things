# Tree

#### 1. 二叉搜索树 (Binary Search Tree, BST)

**核心思想：**
最基础的版本。它遵循一个简单的规则：对于树中的任意节点，其左子树中所有节点的值都小于该节点的值，右子树中所有节点的值都大于该节点的值。

**优点：**

- **实现简单：** 相比于自平衡树，它的插入、删除和查找逻辑最直观，易于编码和理解。
- **平均性能好：** 在输入数据随机分布的情况下，树的高度趋近于 log(n)，各项操作的平均时间复杂度为 O(log n)。
- **空间效率高：** 节点不需要存储额外的平衡信息（如高度或颜色）。

**缺点：**

- **性能不稳定，存在最坏情况：** 如果插入的数据是预先排序好的（或接近有序的），BST会退化成一个链表。在这种情况下，树的高度为 n，所有操作（查找、插入、删除）的时间复杂度都会退化到 **O(n)**，失去了树形结构的优势。

**适用场景：**

- 当数据是随机插入且后续没有大量不平衡的插入/删除操作时。
- 用于教学或实现更复杂数据结构（如AVL和RBT）的基础。
- 在对性能要求不是极度严格，且可以预见数据不会导致严重不平衡的场景。



#### 2. AVL树 (Adelson-Velsky and Landis' Tree)

**核心思想：**
最早的自平衡二叉搜索树。它在BST的基础上增加了一个严格的平衡条件：**任何节点的左右子树高度差的绝对值不能超过1**。这个高度差被称为**平衡因子 (Balance Factor)**，其值只能是 -1、0 或 1。

当插入或删除节点导致某个节点的平衡因子变为 -2 或 2 时，AVL树会通过**旋转操作**（左旋、右旋、左右双旋、右左双旋）来立即恢复平衡。

**优点：**

- **绝对平衡，查找性能最佳：** 由于其严格的平衡策略，AVL树的高度始终保持在 log(n) 级别，因此其**查找操作的性能是所有三种树中最高且最稳定的**，时间复杂度严格为 O(log n)。
- **性能可预测：** 不存在最坏情况的性能退化问题。

**缺点：**

- **插入和删除开销大：** 为了维持严格的平衡，插入和删除节点可能需要进行一次或多次旋转，这使得其修改操作比红黑树更频繁、更耗时。
- **实现复杂：** 需要为每个节点存储平衡因子或高度，并且旋转的逻辑比红黑树更复杂。

**适用场景：**

- **查找密集型应用**：当查找操作的频率远高于插入和删除操作时，AVL树是绝佳选择。
- 例如，数据库索引、需要快速检索且数据不经常变动的场景。

#### 3. 红黑树 (Red-Black Tree, RBT)

**核心思想：**
一种近似平衡的二叉搜索树。它不追求AVL树那样完美的平衡，而是通过一套相对宽松的规则来确保树不会过度不平衡。

**红黑树的五条性质：**

1. 每个节点要么是红色，要么是黑色。
2. 根节点是黑色的。
3. 每个叶子节点（NIL或nullptr）是黑色的。
4. 如果一个节点是红色的，则它的两个子节点都是黑色的（**杜绝了连续的红色节点**）。
5. 从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点（**黑高一致**）。

这五条性质共同确保了**从根到最远叶子节点的路径长度不会超过到最近叶子节点路径长度的两倍**，从而保证了树的高度近似于 log(n)。平衡通过**颜色翻转**和**旋转操作**来维护。

**优点：**

- **综合性能好：** 在查找、插入和删除操作之间取得了很好的平衡。它的查找性能略低于AVL树，但通常优于BST。其插入和删除操作的调整（旋转次数）平均比AVL树少，因此修改操作更快。
- **修改效率高：** 插入或删除最多只需要2次旋转（插入）或3次旋转（删除）就能恢复平衡，且很多时候通过颜色翻转就能解决问题，开销较小。

**缺点：**

- **实现非常复杂：** 五条性质和对应的调整逻辑比AVL树更难理解和实现。
- **查找性能非最优：** 因为是近似平衡，其树高可能比AVL树稍高，导致查找效率略低。

**适用场景：**

- **读写操作频繁的场景：** 当需要频繁地插入、删除和查找数据时，红黑树是理想选择。
- 它是**通用数据结构**的现实标准。例如：
  - C++ STL 中的 std::map, std::set。
  - Java 中的 TreeMap, TreeSet。
  - Linux内核中的完全公平调度器（CFS）和虚拟内存管理。

| 特性           | 二叉搜索树 (BST)             | AVL树                               | 红黑树 (RBT)                       |
| -------------- | ---------------------------- | ----------------------------------- | ---------------------------------- |
| **平衡策略**   | 无                           | 严格平衡 (左右子树高度差 ≤ 1)       | 近似平衡 (基于5条颜色和结构规则)   |
| **查找复杂度** | 平均 O(log n)，最坏 **O(n)** | 严格 O(log n)                       | 严格 O(log n)                      |
| **插入复杂度** | 平均 O(log n)，最坏 **O(n)** | 严格 O(log n)                       | 严格 O(log n)                      |
| **删除复杂度** | 平均 O(log n)，最坏 **O(n)** | 严格 O(log n)                       | 严格 O(log n)                      |
| **平衡操作**   | 无                           | 旋转（频繁）                        | 颜色翻转 + 旋转（相对较少）        |
| **最大高度**   | n (退化为链表)               | ~1.44 * log₂(n)                     | ~2 * log₂(n)                       |
| **主要优点**   | 实现简单，空间开销小         | **查找速度最快**，性能稳定          | **读写综合性能好**，修改效率高     |
| **主要缺点**   | 性能不稳定，可能退化         | 插入/删除时旋转频繁，**修改开销大** | 实现复杂，查找速度略慢于AVL树      |
| **典型应用**   | 教学，简单应用，数据随机     | 查找密集型应用（如数据库索引）      | 通用数据结构（C++ map, Linux内核） |