# C++ 并发编程：数据竞争、互斥量与原子操作对比

## 1.结果如下

Racing Data: 200000000

Write1 takes: 143ms

Write2 takes: 1355ms

Write3 takes: 426ms


* **在没有同步机制的情况下，并发访问共享数据会导致**错误结果**。**
* **std::mutex** **可以确保线程安全，但其性能开销取决于锁的**粒度**。粗粒度锁可能导致低并发，细粒度锁可能导致高开销。**
* **std::atomic** **对于简单的原子操作（如计数器）提供了**高效且无锁的线程安全**方案，通常是性能最佳的选择。**
