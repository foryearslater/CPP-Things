# 并发编程工具详解


## 1. **std::promise** **和** **std::thread** **组合：手动异步任务管理**

**这种组合方式提供了对底层线程创建和异步结果传递的更细粒度的控制，可以被视为构建更复杂并发模型的基础。**

### 核心思想

* **分离生产者与消费者：** **std::promise** **充当**结果的生产者**，它承诺在未来的某个时刻提供一个值。**std::future **充当**结果的消费者**，它能够异步地从** **promise** **获取这个值。**
* **显式线程创建：** **std::thread** **负责创建和管理实际执行任务的独立线程。**

### 工作原理

* **创建** **std::promise** **和** **std::future**：

  * **首先，在发起异步任务的线程（通常是主线程）中创建一个** **std::promise`<T>`** **对象。**
  * **接着，通过** **promise.get_future()** **方法获取与此** **promise** **相关联的** **std::future`<T>`** **对象。此时，**future **处于未就绪状态。**
* **启动** **std::thread** **执行任务：**

  * **创建一个** **std::thread** **对象，并向其传递一个可调用对象（例如 Lambda 表达式或函数），作为新线程的入口函数。**
  * **将** **std::promise** **对象（通常通过引用）传递给这个线程任务，以便任务能够访问它。**
* **任务线程中设置结果：**

  * **在新线程中，执行耗时的异步计算或操作。**
  * **一旦计算完成，通过** **promise.set_value(result)** **方法将结果设置到** **promise** **中。**
  * **此时，与该** **promise** **关联的** **std::future** **会自动变为**就绪状态 (ready state)**，表明结果已可用。**
* **主线程中获取结果：**

  * **在主线程或其他需要结果的线程中，通过** **future.get()** **方法来获取结果。**
  * **future.get()** **是一个**阻塞操作**：它会暂停当前线程的执行，直到** **future** **变为就绪状态（即** **promise** **设置了值）。一旦结果可用，**get() **方法将返回该值。**
* **线程生命周期管理：**

  * **使用** **std::thread** **时，必须显式地管理线程的生命周期，通常通过调用** **thread.join()**（等待线程完成并回收资源）或 **thread.detach()**（使线程独立运行，不再受主线程控制）来完成。

### 优点

* **细粒度控制：** **提供了对线程创建、生命周期管理、任务执行和结果传递的极高控制。**
* **分离关注点：** **std::promise** **专注于结果的生产，**std::future **专注于结果的消费，**std::thread **专注于任务的执行，各自职责明确。**
* **复杂并发场景基础：** **是实现线程池、生产者-消费者队列等更复杂并发模式的基础构建块。**
* **异常传递：** **如果任务线程中抛出异常，**promise **可以通过** **promise.set_exception()** **设置异常，并通过** **future.get()** **在获取结果的线程中重新抛出该异常。**

### 缺点

* **更繁琐的代码：** **相较于** **std::async**，需要手动编写更多代码来创建和管理 **std::thread** **和** **std::promise**。
* **易出错：** **如果忘记调用** **thread.join()** **或** **thread.detach()**，可能导致程序崩溃或资源泄漏。

### 适用场景

* **当你需要**完全控制线程的生命周期**，例如：**

  * **实现自定义的**线程池**。**
* **需要对线程的属性（如优先级、栈大小）进行精确设置。**
* **当你需要在**多个点**异步地传递结果或异常时（尽管** **future.get()** **只能调用一次，但** **promise** **可以设置一次值）。**
* **当你正在构建**底层的并发原语或异步框架**时。**

---

## 2. **std::async**：高级异步任务启动器

**std::async** **是 C++11 提供的一个更高级别的抽象，用于简化异步任务的启动和结果的获取。它在幕后管理了** **std::promise** **和** **std::thread** **的复杂性。**

### 核心思想

* **自动化异步：** **std::async** **旨在让异步编程变得像调用普通函数一样简单，由它自动决定任务的执行方式（新线程或延迟执行）。**
* **直接返回** **std::future**： **它直接返回一个** **std::future** **对象，客户端通过这个** **future** **来获取任务结果，无需手动创建** **std::promise**。

### 工作原理

* **调用** **std::async**：

  * **直接调用** **std::async**，并传入一个可调用对象（函数、Lambda 表达式等），以及可选的启动策略。
  * **例如：**std::future`<int>` result = std::async(my_function, arg1, arg2);
* **自动执行任务：**

  * **std::async** **会根据其**启动策略 (launch policy) **来决定如何执行任务：**

    * **std::launch::async**: 强制在新线程中异步执行任务。
    * **std::launch::deferred**: 强制延迟执行任务。任务只会在 **future.get()** **或** **future.wait()** **被调用时，在调用线程中同步执行。**
    * **std::launch::async | std::launch::deferred** **(默认策略): 运行时由系统（或库实现）决定是在新线程中异步执行，还是延迟执行。这增加了不确定性。**
* **返回** **std::future**：

  * **std::async** **调用会立即返回一个** **std::future`<T>`** **对象。此时，任务可能已经开始执行，也可能尚未执行（如果采用** **deferred** **策略）。**
* **获取结果和自动线程管理：**

  * **通过** **future.get()** **方法来获取任务的最终结果。这会阻塞当前线程，直到任务完成。**
  * **std::async** **最重要的优点之一是**自动处理线程的生命周期**。当与** **std::async** **返回的** **std::future** **对象关联的任务完成后，**std::future **的析构函数（或** **get()** **/** **wait()** **方法）会确保底层线程被正确地** **join()** **或** **detach()**，避免资源泄漏。

### 优点

* **简洁易用：** **代码量显著减少，极大地简化了异步任务的创建和结果的获取。**
* **自动线程管理：** **无需手动创建和** **join()** **或** **detach()** **std::thread**，降低了出错的风险。
* **异常传递：** **异步任务中抛出的任何异常都会被** **std::async** **捕获，并通过** **std::future** **传递到** **get()** **调用处，并在那里重新抛出。**
* **灵活的启动策略：** **允许程序员选择任务的执行方式（立即异步或延迟执行）。**

### 缺点

* **默认策略的不确定性：** **默认的** **std::launch::async | std::launch::deferred** **策略可能导致任务不一定在新线程中执行，这可能与预期不符。如果需要确保任务在新线程中执行，应显式指定** **std::launch::async**。
* **无法精确控制线程：** **抽象掉了线程池等底层线程管理细节，对于需要这些控制的复杂场景，**std::async **不足。**
* **future** **的生命周期陷阱：** **std::future** **的析构函数在默认情况下可能会阻塞调用线程，直到异步任务完成。如果** **std::future** **是一个临时对象并在表达式结束时立即析构，可能会导致同步行为，而不是预期的异步。**

### 适用场景

* **绝大多数简单且独立的异步任务：** **当你只需要在后台执行某个计算并获取其结果，且不关心具体的线程池或底层线程管理时。**
* **提高程序响应性：** **将耗时操作（如文件I/O、复杂计算）移到后台，防止UI冻结或主线程阻塞。**
* **基本并行化：** **将一个大问题分解为几个独立的子任务并行执行。**

---

## 总结

**在 C++11 的异步编程中：**

* **优先使用** **std::async**： **对于大多数日常的、相对独立的异步任务，**std::async **提供了最简洁、最安全、最符合现代 C++ 习惯的解决方案。它将线程管理和结果传递的复杂性抽象掉，让你专注于任务本身。**
* **在特定场景下使用** **std::promise** **/** **std::thread** **组合：** **当** **std::async** **的抽象级别无法满足你的需求，例如，你需要构建自定义线程池、对线程属性进行精细控制、或者实现更复杂的线程间通信机制（如生产者-消费者队列）时，**std::promise **和** **std::thread** **提供了必要的底层灵活性。**
