# C++ 多线程锁粒度与性能对比


**通过一个简单的** **std::vector** **操作场景，对比了在多线程编程中保护共享资源时两种常见的**锁粒度策略**对程序性能的影响：**

* **细粒度锁 (Fine-grained Locking)**：每次对共享资源的原子操作（例如，对向量单个元素的写入）都伴随一次加锁和解锁。
* **粗粒度锁 (Coarse-grained Locking)**：在执行一系列对共享资源的原子操作之前一次性加锁，并在所有操作完成后才解锁。


* **细粒度锁 (**SetValue** **每次操作加锁)**** **：由于对互斥量的频繁加锁和解锁操作（在本例中为** **2 * ADD_SIZE** **次），即使在单线程环境下，这些操作本身也会产生显著的性能开销，导致总执行时间较长。**
* **粗粒度锁 (**MTVectorModifier**)**：通过将锁的范围扩大到整个操作序列，互斥量的加锁和解锁操作仅执行了两次（一次在 **modifier** **构造时，一次在** **modifier** **析构时）。这极大地减少了锁的开销，使得总执行时间大幅缩短。**

1.**锁的开销是显著的。**

2.**在需要对共享资源执行**一系列连续操作**时，采用**粗粒度锁**（在操作序列外部加锁一次）通常比**细粒度锁**（每次操作都加锁）能够获得**更好的性能**。这是因为粗粒度锁有效减少了互斥量操作的次数。**