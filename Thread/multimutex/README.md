# C++ 互斥量与锁管理 (Mutex & Locks)


### 1. 互斥量 (**std::mutex**) - 保护共享资源

* **定义：** **std::mutex** **是一个互斥量（Mutual Exclusion）。它是一种同步原语，用于保护共享资源，确保在任何给定时刻，**只有一个线程**可以访问受保护的代码或数据区域。**
* **功能：**

  * **lock()**： **尝试锁定互斥量。如果互斥量已经被其他线程锁定，当前线程会**阻塞**，直到互斥量可用并被成功锁定。**
  * **unlock()**： **解锁互斥量。**
  * **try_lock()**： **尝试锁定互斥量。如果互斥量可用，则立即锁定并返回** **true**；如果不可用，则立即返回 **false**，不会阻塞。
* **使用场景：** **任何需要独占访问共享数据的地方。**


### 2. **std::lock_guard** **- RAII 风格的单互斥量锁守卫 (C++11)**

* **定义：** **std::lock_guard** **是一个轻量级的 RAII (Resource Acquisition Is Initialization) 风格的互斥量守卫。**
* **RAII 原则：** **资源（在这里是互斥量的锁定）在对象构造时获取，在对象析构时释放。**
* **功能：**

  * **构造时：** **自动调用其构造函数参数中互斥量的** **lock()** **方法，尝试锁定互斥量。**
  * **析构时：** **无论代码如何退出当前作用域（正常完成、**return**、抛出异常），**lock_guard **对象都会被析构，并在析构函数中自动调用互斥量的** **unlock()** **方法。**
* **优点：**

  * **自动解锁：** **解决了手动** **unlock()** **的问题，大大提高了代码的健壮性和安全性。**
  * **简单易用：** **只需一行代码即可保护一个临界区。**
* **缺点：**

  * **不能移动或复制：** **lock_guard** **不可移动，也不可复制。**
  * **只能管理一个互斥量：** **lock_guard** **只能管理单个互斥量。**
  * **不支持延迟锁定：** **lock_guard** **总是尝试在构造时立即锁定，没有提供** **try_lock** **或** **adopt_lock** **等选项。**

### 3. **std::scoped_lock** **- RAII 风格的多互斥量锁守卫 (C++17)**

* **定义：** **std::scoped_lock** **是** **std::lock_guard** **的升级版，也是 RAII 风格的锁守卫。它专门设计用于**同时锁定一个或多个互斥量**。**
* **主要改进：**

  * **多互斥量锁定：** **可以在构造时传入任意数量的互斥量。**
  * **死锁避免：** **std::scoped_lock** **的构造函数会使用**死锁避免算法，以确保在尝试锁定多个互斥量时不会发生死锁。它会以一种原子且安全的方式获取所有锁，或在无法全部获取时，释放已获取的锁并重试，直到成功。
* **优点：**

  * **自动解锁：** **同** **lock_guard**，确保资源安全释放。
  * **死锁安全：** **这是它最重要的特性，大大简化了多互斥量场景下的并发编程。**
  * **可变参数模板：** **可以接受任意数量的** **std::mutex** **或其他兼容的锁类型。**
* **缺点：**

  * **C++17 特性，需要较新的编译器支持。**
  * **不支持** **try_lock** **等非阻塞锁定。**
