# C++ 条件变量(Condition Variable Example)

**实现了最简单的**生产者-消费者模型 (Producer-Consumer Model)**：一个主线程（生产者）生成数据并将其放入共享容器，而另一个工作线程（消费者）则从该容器中取出并处理数据。条件变量用于确保消费者线程在没有数据可处理时高效地等待，并在数据可用时被及时通知。**

* **互斥量 (**std::mutex**)** **:**
* **std::mutex** **是一个互斥量，用于保护共享资源** **data**，确保在任何给定时刻只有一个线程可以访问和修改它，从而避免竞态条件。
* **在生产者-消费者模型中，互斥量是保护共享队列的关键。**
* **条件变量 (**std::condition_variable**)**:

  * **std::condition_variable** **用于线程间的等待和通知。**
* **等待 (Wait)**：一个线程可以在条件不满足时在条件变量上等待，它会原子性地释放互斥量并进入阻塞状态。
* **通知 (Notify)**：另一个线程可以在条件满足时通知等待的线程，使其从阻塞状态中被唤醒，并重新获取互斥量。
* **共享资源 (**std::vector `<double>` data**)**:

  * **一个** **std::vector `<double>`**，充当生产者和消费者之间的数据缓冲区（队列）。
* **std::unique_lock**:

  * **std::unique_lock** **是一个灵活的 RAII 风格的锁管理类。**
* **它是** **std::condition_variable::wait()** **方法的**必需参数**，因为它允许在线程等待期间临时释放互斥量，并在被唤醒后重新获取互斥量。**
* **wait()** **函数会在线程进入阻塞状态前检查这个谓词。如果为** **true**，线程不会阻塞。
* **当线程被唤醒后，**wait() **会再次检查谓词。如果仍然为** **false**，线程会再次进入阻塞状态。这有效地避免了**虚假唤醒 (Spurious Wakeups)**。
* **std::jthread** **(C++20)**:

  * **C++20 引入的** **std::jthread** **是** **std::thread** **的改进版本。**
* **自动** **join()**: **std::jthread** **对象在析构时会自动调用** **join()**，无需手动管理线程的生命周期，避免了悬空线程。
