# 组合模式 (Composite Pattern)

## 1. 意图 (Intent)

**组合模式**的核心意图是：**将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。**

**简单来说，这个模式允许你像对待一个**单独的**对象（叶子节点）一样，去对待一组**组合起来的**对象（容器节点）。客户端代码无需关心它正在处理的是一个简单的“文件”还是一个复杂的“文件夹”，因为它们都提供了相同的接口。**

## 2. 动机 (Motivation)

   **想象一下，你正在开发一个图形编辑器。画布上的对象可以是简单的图形，如**圆形（Circle）**、**直线（Line）**，也可以是复杂的图形，如**图片（Picture）**。一张图片本身是由许多圆形、直线和其他图形组合而成的。**

   **现在，你需要实现一个** **draw()** **方法来绘制这些图形。**

* **对于** **Circle** **和** **Line**，**draw()** **方法很简单。**
* **对于** **Picture**，它的 **draw()** **方法需要遍历它内部包含的所有图形，并依次调用它们各自的** **draw()** **方法。**

**这里出现了一个问题：客户端代码在绘制时，必须区分它处理的是一个简单图形还是一个复杂图形（图片）。代码可能会变成这样：**

Generated code

```
// 客户端代码
for (each object on canvas) {
    if (object is a simple Shape) {
        object.draw();
    } else if (object is a Picture) {
        // 需要特殊处理，遍历其内部元素
        object.draw(); 
    }
}
```

Use code [with caution](https://support.google.com/legal/answer/13505487).

**这种** **if/else** **的结构使得代码变得复杂和脆弱。每当你增加一种新的复杂图形类型，你就需要修改这里的代码。**

**组合模式通过创建一个**统一的接口**来解决这个问题。我们可以定义一个** **Graphic** **接口，它有一个** **draw()** **方法。无论是** **Circle**（简单图形）还是 **Picture**（复杂图形），都实现这个接口。这样，客户端代码就可以用完全相同的方式对待它们，极大地简化了客户端的逻辑。

Generated code

```
// 使用组合模式后的客户端代码
for (each graphic_component on canvas) {
    graphic_component.draw(); // 无需区分，统一调用
}
```

Use code [with caution](https://support.google.com/legal/answer/13505487).

## 3. 适用场景 (Applicability)

**在以下情况，应当优先考虑使用组合模式：**

* **当你需要表示对象的**“部分-整体”层次结构**时。例如，文件系统中的文件和文件夹，组织架构中的部门和员工，图形界面中的控件和容器。**
* **当你希望客户端代码能够**统一地处理**组合结构中的所有对象（无论是单个对象还是组合对象），而无需进行类型检查和区分。**
* **当数据结构可以自然地表示为一个**树形结构**时。**

## 4. 结构 (Structure)

**组合模式通常包含以下三个核心角色：**

```
![alt text](https://refactoring.guru/images/patterns/diagrams/composite/structure.png)
```

(图片来源: refactoring.guru)

* **Component (组件)**

  * **这是一个接口或抽象类，为组合中的所有对象（包括叶子和组合节点）声明了**统一的接口**。**
  * **它定义了所有对象共有的行为，例如** **operation()**。
  * **它还可以（可选地）为管理子组件的操作（如** **add()**, **remove()**, **getChild()**）提供默认实现。
* **Leaf (叶子)**

  * **表示组合中的**基本对象**，它**没有子节点**。**
  * **它实现了** **Component** **接口中定义的操作。**
  * **对于管理子组件的操作（如** **add()**, **remove()**），它通常会提供一个空的实现、抛出异常或什么都不做，因为它不能有子节点。
  * **例如，文件系统中的** **File**。
* **Composite (组合)**

  * **表示组合中的**容器对象**，它可以**包含子组件**（这些子组件可以是叶子，也可以是其他的组合节点）。**
  * **它实现了** **Component** **接口。对于它自己的操作，它通常会将请求**委托**给它的子组件来执行，并可能在子组件的结果上进行一些额外的处理。**
  * **它实现了管理子组件的方法（**add()**,** **remove()** **等）。**
  * **例如，文件系统中的** **Folder**。

## 5. 运作流程 (Collaborations)

* **客户端代码通过**组件（Component）**接口与组合结构中的所有对象进行交互。**
* **如果客户端操作的是一个**叶子（Leaf）**对象，请求会直接在这个叶子对象上被处理。**
* **如果客户端操作的是一个**组合（Composite）**对象，它通常会遍历其内部的子组件列表，并将请求**递归地**转发给每一个子组件。子组件接收到请求后，会重复这个过程。**
* **因此，一个对顶层组合对象的请求，会沿着整个树状结构向下传播，直到所有的叶子节点都被访问到。**

## 6. 优缺点 (Pros and Cons)

### 优点:

* **简化客户端代码**：客户端可以统一地处理所有对象，代码变得非常简单，并且与复杂的树状结构解耦。
* **易于增加新类型的组件**：无论是增加新的叶子节点还是新的组合节点，都非常容易，因为它们只需要实现统一的 **Component** **接口。这符合“开闭原则”。**
* **结构清晰**：可以清晰地定义出包含“部分-整体”关系的层次结构。

### 缺点:

* **设计过于通用可能导致困难**：有时候，你可能想限制一个组合对象只能包含特定类型的子组件。在组合模式的标准实现中，**Component** **接口使得任何组件都可以被添加到任何组合中，这可能不符合某些业务逻辑。**
* **难以限制组件类型**：在运行时进行类型检查来限制组件类型，可能会使代码变得复杂，并失去组合模式带来的透明性优势。
* **接口定义的选择**：将管理子组件的方法（**add**, **remove**）定义在 **Component** **基类中，会使得** **Leaf** **类也拥有这些方法（尽管它们是空的），这在设计上可能不够“干净”。但如果将这些方法只定义在** **Composite** **类中，又会失去透明性，客户端需要进行类型转换才能添加子节点。这是一个经典的设计权衡。**

## 7. 与其他模式的关系

* **组合模式** **vs.** **装饰器模式 (Decorator)**:

  * **两者都使用了**递归组合**的结构。**
* **核心区别**：装饰器模式旨在为对象**添加额外的职责**，它通常只包装一个组件；而组合模式旨在**聚合一组对象**，它代表了其所有子组件的集合。
* **组合模式** **vs.** **访问者模式 (Visitor)**:

  * **访问者模式是组合模式的绝佳搭档。当你想在整个组合树上执行一个复杂的操作，而又不想污染** **Component** **接口时，可以使用访问者模式来将这个操作封装起来。**
* **组合模式** **vs.** **职责链模式 (Chain of Responsibility)**:

  * **职责链通常是一个**线性**的结构，请求沿着链条单向传递，直到被处理。**
* **组合模式则是一个**树状**结构，请求通常会从父节点广播给**所有**子节点。**
