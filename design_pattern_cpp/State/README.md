
# 状态模式 (State Pattern)

## 概述

**状态模式（State Pattern）是一种行为型设计模式。它的核心思想是**允许一个对象在其内部状态改变时改变它的行为。对象看起来好像改变了它的类。

 **想象一下一个自动贩卖机。当机器里没有钱时，你按“购买”按钮是无效的；当你投入硬币后，按“购买”按钮就可以出货；但如果商品卖完了，无论你投多少钱，按“购买”按钮都无法出货。贩卖机**同一个动作（按“购买”按钮）**在**不同状态**下（没钱、有钱、售罄）表现出**不同的行为**。状态模式正是为了管理这种行为随状态变化而变化的情况。**

## 意图

* **当一个对象的行为取决于它的状态，并且它必须在运行时改变它的行为时。**
* **消除对象行为中大量的条件语句（如** **if-else if-else** **或** **switch-case**），这些语句根据对象的状态来决定执行哪个操作。
* **将与特定状态相关的行为封装到独立的类中。**

## 解决的问题

**在软件开发中，我们常常会遇到以下情况：**

* **行为随状态而变：** **一个类的行为会根据其内部状态的不同而发生显著变化。**
* **大量的条件逻辑：** **类的某个方法（或多个方法）中包含大量** **if-else if-else** **或** **switch-case** **语句，用于根据对象的当前状态来分派不同的行为。这使得代码变得臃肿、难以阅读、维护和扩展。**
* **状态转换逻辑混乱：** **状态之间的转换逻辑分散在代码的各个角落，难以追踪和理解。**
* **违反开放/封闭原则：** **每当需要添加新的状态或修改现有状态的行为时，都必须修改包含这些条件语句的核心类，这违反了开放/封闭原则（对扩展开放，对修改封闭）。**

**状态模式通过引入一个抽象状态接口和多个具体状态类，将每个状态的行为封装在独立的类中，从而解决了这些问题。**

## 模式结构

**状态模式通常包含以下几个关键参与者：**

* **上下文 (Context):**

  * **维护一个指向当前**具体状态**对象的引用。**
  * **它**委托（delegate）**状态相关的请求到当前状态对象。**
  * **客户端只与上下文交互，无需了解具体状态类的细节。**
  * **它可能包含所有具体状态类的实例（例如，作为单例或在上下文初始化时创建），并在内部进行状态切换。**
* **抽象状态 (State):**

  * **定义了一个接口，封装了与**特定状态**相关的行为。**
  * **它通常包含上下文可能执行的所有操作的抽象方法。**
  * **所有具体状态类都必须实现这个接口。**
* **具体状态 (Concrete State):**

  * **实现抽象状态接口。**
  * **每个具体状态类实现一个特定状态下的行为。**
  * **每个方法都包含在该特定状态下对上下文操作的具体逻辑。**
  * **在特定条件下，具体状态对象可能会改变上下文的当前状态（通过调用上下文的** **SetState()** **方法）。**

## 工作原理

* **初始化：** **上下文对象被创建时，会初始化一个默认的（或初始的）具体状态对象，并将其设置为当前状态。上下文通常会创建并持有所有可能的状态对象实例。**
* **请求委托：** **当客户端调用上下文对象上的一个方法时，上下文不会直接执行该方法，而是将请求**委托**给其当前持有的具体状态对象。**
* **状态行为：** **当前具体状态对象的相应方法被调用。它执行与该状态相关的行为。**
* **状态转换：** **在执行过程中，当前具体状态对象可能会根据某些条件（例如，用户输入、内部数据变化）决定将上下文的当前状态更改为另一个具体状态。这是通过调用上下文的** **SetState()** **方法并传入新的状态对象来实现的。**
* **透明性：** **客户端代码只与上下文对象交互，对于上下文内部的状态变化和行为委托是透明的，客户端不知道也不关心当前上下文处于哪个具体状态。**

## 优缺点

### 优点：

* **消除条件语句：** **彻底消除了上下文类中基于状态的大型** **if-else if-else** **或** **switch-case** **条件语句，使上下文的代码更简洁、更易于阅读和维护。**
* **行为局部化：** **将与特定状态相关的行为封装在一个独立的具体状态类中，使得修改或添加某个状态的行为变得容易。**
* **遵循开放/封闭原则：** **增加新的状态时，只需创建新的具体状态类并修改相关的状态转换逻辑，无需修改上下文类和其他现有状态类。**
* **清晰的状态转换：** **状态转换逻辑被明确地定义在具体状态类中，使得状态机的结构和流程更加清晰。**
* **提高可复用性：** **状态类可以在不同的上下文对象中复用。**

### 缺点：

* **增加类数量：** **对于每个状态，都需要创建一个新的具体状态类，这会增加类的数量，使得系统结构看起来更复杂。对于只有少量状态且行为变化不大的情况，可能显得过度设计。**
* **分散逻辑：** **虽然行为被局部化，但一个操作（例如“购买”）的具体执行逻辑可能分散在多个具体状态类中，追踪整个操作的完整流程可能需要查看多个文件。**
* **状态共享问题：** **如果多个上下文实例需要共享相同的状态对象，需要确保状态对象是无状态的（stateless），或者使用单例模式来管理状态对象。**

## 适用场景

* **当一个对象的行为取决于它的状态，并且它必须在运行时改变它的行为时。**
* **当一个类的操作中含有庞大的、基于状态的条件语句时。**
* **当对象状态的转换规则复杂，且需要明确地在代码中表示这些转换时。**
* **当你想避免客户端代码直接依赖于具体的、状态相关的实现时。**
* **例如，用户界面的交互状态（编辑、选择、拖拽）、游戏角色状态（站立、行走、攻击）、网络连接状态（连接中、已连接、断开）等。**

## 与其他模式的关系

* **策略模式 (Strategy Pattern):**

  * **非常相似：** **结构上非常相似，都涉及上下文委托行为给一个实现共同接口的对象。**
  * **区别：** **状态模式关注**行为随着内部状态的变化而变化**，状态通常由内部（具体状态类）自行改变。策略模式关注**可替换的算法或行为**，策略通常由外部（客户端）来选择和设置。简单来说，状态模式是**对象行为的内部改变**，策略模式是**对象算法的外部改变**。**
  * **两者可以结合使用：一个状态可以委托给一个策略来执行特定的行为。**
* **有限状态机 (Finite State Machine, FSM):** **状态模式是实现有限状态机最常用、最优雅的方式之一。**
* **单例模式 (Singleton Pattern):** **如果状态对象是无状态的，并且可以被多个上下文实例共享，那么具体状态对象可以被实现为单例。**
* **享元模式 (Flyweight Pattern):** **如果具体状态对象可以被大量上下文实例共享以节省内存，并且它们是无状态的，可以考虑结合享元模式。**

## 总结

**状态模式通过将每个状态的行为封装到独立的具体状态类中，有效地解决了行为随状态变化的复杂性，并消除了传统方法中大量的条件判断语句。它使得状态转换清晰可控，提高了代码的可读性、可维护性和可扩展性，是设计复杂状态机和响应式系统的重要工具。**
