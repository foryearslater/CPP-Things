
# 模板方法模式 (Template Method Pattern)

## 概述

**模板方法模式（Template Method Pattern）是一种行为型设计模式。它的核心思想是**在一个抽象类中定义一个算法的骨架（即模板方法），而将一些具体步骤延迟到子类中实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些特定步骤。

**想象一下制作一份标准文档（例如，报告或简历）。无论报告的内容是什么，它都有一个固定的流程：标题、目录、正文、结论、参考文献。其中，“正文”和“结论”的具体内容因报告而异，而其他步骤是固定的。模板方法模式就是将这个固定的“制作文档”流程定义在基类中，而将“填写正文”和“撰写结论”这些可变步骤留给子类去实现。**

## 意图

* **定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。**
* **使子类可以在不改变算法的结构的情况下，重新定义该算法的某些特定步骤。**
* **提供算法的通用实现，同时允许子类提供其细节实现。**

## 解决的问题

**在软件开发中，我们常常会遇到以下情况：**

* **算法的通用结构与可变步骤：** **多个类都遵循相同的基本算法流程，但其中某些步骤的实现方式各不相同。**
* **重复代码：** **如果不使用模板方法模式，每个类可能会复制粘贴相同的算法骨架，只修改其中少数不同的步骤，导致大量重复代码。**
* **强制执行特定顺序：** **某些操作的步骤必须按照特定的顺序执行，不能被随意打乱。**
* **违反开放/封闭原则：** **如果算法结构或某个通用步骤需要修改，可能需要修改所有相关类。**

**模板方法模式通过将算法的骨架（固定步骤和调用抽象/钩子步骤）定义在抽象基类中，并强制子类实现抽象步骤，从而解决了这些问题。**

## 结构

**模板方法模式通常包含以下几个关键参与者：**

* **抽象类 (Abstract Class):**

  * **定义了算法的**模板方法**。这个模板方法是一个具体的（非抽象的）方法，它定义了算法的骨架，即一系列调用的步骤。**
  * **模板方法中会调用一些**抽象方法**（由子类实现）和/或**具体方法**（由基类实现）和/或**钩子方法**（Hook Methods）。**
  * **声明（或实现）所有具体子类共有的步骤。**
  * **可以包含钩子方法，提供默认实现，允许子类选择性地重写。**
* **具体类 (Concrete Class):**

  * **继承抽象类。**
  * **实现抽象类中定义的所有**抽象方法**，以提供算法中可变步骤的具体实现。**
  * **可以重写**钩子方法**，以改变算法中可选步骤的行为。**
  * **通常不应该重写模板方法本身（因为它定义了算法的骨架）。**

## 工作原理

* **定义算法骨架：** **在抽象基类中，定义一个公共的模板方法（例如** **processOrder()**、**makeCoffee()** **等）。这个模板方法是** **public** **的，它包含了整个算法的完整执行流程，其中有些步骤是通用的，有些是抽象的。**
* **实现通用步骤：** **抽象基类可以实现一些在算法中所有子类都相同的通用步骤。**
* **定义抽象步骤：** **抽象基类声明一些抽象方法（例如** **brew()**、**addCondiments()**），这些方法在模板方法中被调用，但具体实现由子类负责。
* **提供钩子（可选）：** **抽象基类可以提供一些钩子方法，它们是带有默认实现的空方法或返回布尔值的方法。子类可以选择性地重写这些钩子来影响算法的流程（例如，**customerWantsCondiments()**）。**
* **具体实现：** **具体子类继承抽象基类，并实现所有抽象方法，从而为算法的可变部分提供具体的逻辑。它们也可以重写钩子方法来定制可选行为。**
* **客户端调用：** **客户端代码只与抽象基类交互（通过多态），并调用其模板方法。模板方法会按照预定义的骨架执行，并在需要时调用子类实现的具体步骤。**

## 优缺点

### 优点：

* **实现代码复用：** **将算法的通用部分（骨架和通用步骤）集中在抽象基类中，避免了子类之间的重复代码。**
* **强制执行特定顺序：** **模板方法确保算法的步骤以正确的顺序执行，子类无法改变算法的结构。**
* **遵循开放/封闭原则：** **算法的固定部分被封闭，但可以通过创建新的子类来扩展算法的可变部分，而无需修改现有代码。**
* **提高可维护性：** **算法的流程清晰定义，每个步骤的实现被封装在各自的类中。**
* **“好莱坞原则”：** **“不要调用我们，我们来调用你。” 子类只实现被基类调用的特定步骤，而不是由客户端直接调用。**

### 缺点：

* **继承限制：** **模板方法模式基于继承，可能导致以下问题：**

  * **如果算法中只有一两个步骤是可变的，但基类定义了大量抽象方法，子类可能需要实现许多不相关的空方法。**
  * **在某些不支持多重继承的语言中（如 Java），如果子类已经继承了其他类，就无法再继承抽象模板方法类。**
* **增加复杂性：** **对于简单算法，引入模板方法模式可能会增加不必要的抽象层次和类数量。**
* **行为受限：** **算法的骨架是固定的，如果需要改变骨架本身，则需要修改抽象基类，这可能影响所有子类。**
* **可能破坏封装性：** **抽象基类可能需要访问子类的内部状态，或者需要子类暴露一些其通常不会暴露的方法，这可能破坏封装性。**

## 适用场景

* **当多个类具有相似的算法，但其中某些步骤的实现不同时，可以将这些重复的代码提取到抽象基类中。**
* **当算法的步骤顺序是固定的，但某些步骤的实现细节需要根据具体情况而变化时。**
* **当需要强制子类遵循一个特定的操作流程时。**
* **当你想允许子类通过重写部分操作来扩展算法，而又不想它们改变算法的结构时。**
* **例如，文档生成流程（Word、PDF）、数据处理流程（读取、转换、保存）、游戏AI行为（通用AI决策树，具体AI行动）、算法框架等。**

## 与其他模式的关系

* **策略模式 (Strategy Pattern):**

  * **相似性：** **都可以处理算法的变化。**
  * **区别：** **模板方法通过**继承**实现，在抽象基类中定义算法骨架，子类重写特定步骤。策略模式通过**组合**实现，将完整算法封装在独立对象中，上下文引用这些对象。策略模式提供了更高的运行时灵活性（可以在运行时切换算法），而模板方法在编译时固定了算法的骨架。**
  * **两者可以结合使用：模板方法中的某个步骤可以委托给一个策略对象来执行。**
* **工厂方法模式 (Factory Method Pattern):**

  * **模板方法中的某个步骤可以是一个工厂方法，用于创建算法所需的特定对象。**
* **钩子方法 (Hook Method):** **钩子方法是模板方法模式中的一个重要组成部分，它使得子类可以在模板方法的特定点插入自定义逻辑，或者选择性地跳过某些步骤。**

## 总结

**模板方法模式通过在抽象基类中定义算法的骨架，并将可变步骤延迟到子类实现，有效地实现了代码复用、强制执行特定顺序和遵循开放/封闭原则。它适用于那些具有通用流程但部分细节可定制的场景，是设计具有良好扩展性和可维护性算法的重要工具。**
