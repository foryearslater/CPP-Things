## 设计模式分类 (GoF 23 种模式)

**GoF（Gang of Four，四人帮）将设计模式分为三类：创建型、结构型和行为型。**

### 一、创建型模式 (Creational Patterns)

**这类模式主要关注对象的创建过程，它们解耦了客户端与需要创建的具体类，使得系统在创建对象时更灵活。**

#### 1. 单例模式 (Singleton Pattern)

* **目的：** **确保一个类只有一个实例，并提供一个全局访问点。**
* **优点：**

  * **控制对唯一实例的访问，避免资源冲突。**
  * **节省系统资源，尤其是在对象创建开销大或资源稀缺时。**
  * **可以延迟初始化，只有在第一次使用时才创建实例。**
* **缺点：**

  * **引入全局状态，可能导致紧耦合和测试困难。**
  * **多线程环境下需要额外处理线程安全，增加了复杂性。**
  * **违反了“单一职责原则”（SRP），因为它既管理了自身的创建，又处理了业务逻辑。**
* **适用场景：** **配置管理器、日志系统、线程池、缓存等。**

#### 2. 工厂方法模式 (Factory Method Pattern)

* **目的：** **定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。**
* **优点：**

  * **解耦了产品的创建和使用，客户端无需关心具体产品类的实例化细节。**
  * **符合“开放-封闭原则”（OCP），增加新产品时只需添加新的具体工厂和产品类，无需修改现有代码。**
  * **每个具体工厂负责一种产品的创建，职责清晰。**
* **缺点：**

  * **每增加一种产品，就需要增加一个具体工厂类，可能导致类的数量膨胀。**
  * **客户端可能需要知道并选择具体的工厂类，而非完全隐藏创建细节。**
* **适用场景：** **日志记录器（文件日志、数据库日志）、不同类型的导出器、图形界面的各种按钮或文本框的创建。**

#### 3. 抽象工厂模式 (Abstract Factory Pattern)

* **目的：** **提供一个接口，用于创建相关或依赖对象的家族，而无需指定它们的具体类。**
* **优点：**

  * **保证了产品族内部的一致性，客户端使用的产品总是相互兼容的。**
  * **隔离了客户端与具体产品类的实现，客户端只依赖于抽象接口。**
  * **符合“开放-封闭原则”，增加新的产品族非常容易。**
* **缺点：**

  * **难以扩展新的产品种类，如果增加新的产品类型，需要修改所有具体工厂和抽象接口。**
  * **系统复杂度增加，类的数量更多。**
* **适用场景：** **UI 工具包（创建不同操作系统风格的按钮、文本框等）、数据库访问层（不同数据库的连接、命令对象）、多平台应用程序。**

#### 4. 建造者模式 (Builder Pattern)

* **目的：** **将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。**
* **优点：**

  * **能够分步构建对象，提供更精细的控制，可以创建不同形态的产品。**
  * **将复杂对象的构建逻辑与业务逻辑分离，提高了代码的可读性和可维护性。**
  * **易于扩展新的产品表示，无需修改现有代码。**
  * **可以创建不可变对象（Immutable Objects）。**
* **缺点：**

  * **如果对象的内部结构简单，使用建造者模式可能会引入不必要的复杂性。**
  * **类的数量会增加，因为它至少需要一个建造者接口、一个具体建造者和一个指导者。**
* **适用场景：** **创建复杂对象，如文档生成器、邮件发送器、游戏角色创建、SQL查询构建。**

#### 5. 原型模式 (Prototype Pattern)

* **目的：** **通过复制（克隆）现有对象来创建新对象，而不是通过实例化类。**
* **优点：**

  * **避免了客户端直接依赖具体类，通过复制接口创建对象。**
  * **当对象的创建过程复杂或耗时时，克隆比重新创建更高效。**
  * **可以在运行时动态地添加或修改对象的新特性。**
* **缺点：**

  * **深拷贝（Deep Copy）和浅拷贝（Shallow Copy）的选择和实现可能很复杂，尤其当对象包含复杂引用时。**
  * **每个需要被克隆的类都必须实现克隆接口，可能侵入业务类。**
* **适用场景：** **对象的创建成本很高但数量很多时、动态加载数据、复杂对象的初始化。**

### 二、结构型模式 (Structural Patterns)

**这类模式关注如何组合类和对象以形成更大的结构，它们通常处理类或对象之间的关系，以实现更大的灵活性和效率。**

#### 1. 适配器模式 (Adapter Pattern)

* **目的：** **将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。**
* **优点：**

  * **使得不兼容的接口能够协同工作，提高了类的复用性。**
  * **解耦了客户与被适配者，客户代码无需修改即可使用新的接口。**
  * **可以在不修改原有类的情况下，引入新的功能。**
* **缺点：**

  * **增加了系统的复杂性，引入了一个新的适配器类。**
  * **过多的适配器会使得系统难以管理。**
* **适用场景：** **遗留系统与新系统的整合、不同数据格式的转换、第三方库的集成。**

#### 2. 桥接模式 (Bridge Pattern)

* **目的：** **将抽象与实现解耦，使它们可以独立变化。**
* **优点：**

  * **分离了抽象和实现，两者可以独立扩展，符合“开放-封闭原则”。**
  * **减少了类的数量，避免了类的“爆炸式”增长（比如圆形红色、圆形蓝色、方形红色、方形蓝色等组合）。**
  * **提高了系统的灵活性和可扩展性。**
* **缺点：**

  * **增加了系统的理解和设计难度，因为需要识别抽象和实现两个维度。**
  * **正确的抽象和实现划分需要一定的经验。**
* **适用场景：** **图形绘制（形状与颜色）、跨平台UI开发、消息发送（发送方式与消息类型）、数据库驱动。**

#### 3. 组合模式 (Composite Pattern)

* **目的：** **将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。**
* **优点：**

  * **统一了叶子对象和组合对象的处理方式，简化了客户端代码。**
  * **易于扩展新的组件类型，符合“开放-封闭原则”。**
  * **清晰地定义了复杂的层次结构。**
* **缺点：**

  * **设计会变得过于通用，导致组件无法限制可以包含的子组件类型。**
  * **如果过度使用，可能导致系统中的所有对象都实现了共同的接口，使得类型检查变得困难。**
* **适用场景：** **文件系统、GUI 组件（如面板包含按钮和文本框）、组织结构图、菜单。**

#### 4. 装饰器模式 (Decorator Pattern)

* **目的：** **动态地给一个对象添加一些额外的职责。相较于继承，装饰器模式更加灵活，能避免类爆炸。**
* **优点：**

  * **比继承更灵活，可以在运行时动态地添加或删除功能。**
  * **避免了类的“爆炸式”增长，符合“开放-封闭原则”。**
  * **可以叠加多个装饰器，实现功能的任意组合。**
* **缺点：**

  * **会创建许多小对象，增加系统复杂性。**
  * **装饰器与被装饰器链条过长时，调试会变得复杂。**
  * **客户端可能会对对象进行层层包装，导致代码不易理解。**
* **适用场景：** **I/O 流的各种功能增强（BufferedInputStream、DataInputStream）、图形界面的边框和滚动条、咖啡订单的各种调料。**

#### 5. 外观模式 (Facade Pattern)

* **目的：** **为子系统中的一组接口提供一个统一的接口。外观模式定义了一个高层接口，这个接口使得子系统更容易使用。**
* **优点：**

  * **简化了复杂子系统的使用，隐藏了其内部复杂性。**
  * **降低了客户端与子系统之间的耦合度。**
  * **有助于分层设计，使系统结构更清晰。**
* **缺点：**

  * **如果外观类设计不当，可能成为“上帝对象”（God Object），承担过多职责。**
  * **不符合“开放-封闭原则”，当子系统内部发生变化时，可能需要修改外观类。**
* **适用场景：** **操作系统API、复杂框架的入口、多媒体库、银行系统。**

#### 6. 享元模式 (Flyweight Pattern)

* **目的：** **运用共享技术有效地支持大量细粒度对象。**
* **优点：**

  * **极大地节省内存，尤其是在需要创建大量类似对象时。**
  * **提高了性能，因为对象数量减少，垃圾回收频率降低。**
* **缺点：**

  * **增加了系统的复杂性，需要将对象的状态分离为内部状态和外部状态。**
  * **外部状态的管理和传递可能比较复杂。**
  * **不适用于所有情况，只有当对象间存在大量可共享的内部状态时才有效。**
* **适用场景：** **文本编辑器中的字符、游戏中的树木或草地、网络连接池、数据库连接池。**

#### 7. 代理模式 (Proxy Pattern)

* **目的：** **为另一个对象提供一个替身或占位符以控制对这个对象的访问。**
* **优点：**

  * **可以在不修改原有对象的情况下，增加额外的功能（如延迟加载、权限控制、日志记录、远程访问）。**
  * **隐藏了真实的复杂性，提供了更简单的接口。**
  * **实现了对对象的访问控制。**
* **缺点：**

  * **增加了一层间接性，可能导致请求处理速度变慢。**
  * **引入了新的类，增加了系统的复杂性。**
  * **如果滥用，可能导致代码难以追踪。**
* **适用场景：** **远程代理（RMI）、虚拟代理（延迟加载大对象）、保护代理（权限控制）、智能引用代理（引用计数）。**

### 三、行为型模式 (Behavioral Patterns)

**这类模式关注对象之间如何协作以及它们之间如何分配职责，描述了对象和类如何交互以及职责如何分配。**

#### 1. 责任链模式 (Chain of Responsibility Pattern)

* **目的：** **为解除请求的发送者和接收者之间的耦合，允许责任链上的多个对象都有机会处理这个请求。请求沿着这条链传递，直到有一个对象处理它为止。**
* **优点：**

  * **降低了发送者和接收者之间的耦合度。**
  * **可以灵活地增减或调整处理者的顺序。**
  * **符合“开放-封闭原则”，增加新的处理者无需修改现有代码。**
* **缺点：**

  * **请求可能无法被处理，如果没有处理者能够处理该请求，它可能会到达链的末端而未被处理。**
  * **调试起来比较困难，因为请求的处理路径不明确。**
  * **链的长度和复杂度可能增加系统开销。**
* **适用场景：** **工作流审批、事件处理、日志级别处理、过滤器链（如Servlet Filter）。**

#### 2. 命令模式 (Command Pattern)

* **目的：** **将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。**
* **优点：**

  * **解耦了请求的发送者和接收者。**
  * **易于实现撤销/重做功能。**
  * **可以方便地组织命令队列，支持宏命令。**
  * **可以将命令持久化，实现事务日志。**
* **缺点：**

  * **会创建大量的具体命令类，增加系统复杂性。**
  * **如果命令的粒度过细，可能导致类的数量膨胀。**
* **适用场景：** **GUI 系统的菜单/按钮操作、宏命令录制、事务处理、任务调度、多级撤销操作。**

#### 3. 解释器模式 (Interpreter Pattern)

* **目的：** **给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。**
* **优点：**

  * **文法规则通过类来表示，易于扩展和维护。**
  * **适用于简单的、重复出现的语言解析问题。**
* **缺点：**

  * **当文法规则变得复杂时，类的数量会急剧增加，难以管理。**
  * **效率可能不高，对性能要求高的场景不适合。**
* **适用场景：** **SQL解析器、正则表达式解析器、迷你语言的实现、简单规则引擎。**

#### 4. 迭代器模式 (Iterator Pattern)

* **目的：** **提供一种方法顺序访问一个聚合对象中各个元素，而又无需暴露该对象的内部表示。**
* **优点：**

  * **将遍历操作与集合对象分离，使得集合对象更专注于自身数据。**
  * **支持多种遍历方式，可以方便地增加新的遍历方式。**
  * **为不同的集合结构提供统一的遍历接口。**
* **缺点：**

  * **对于简单的集合遍历，可能引入不必要的复杂性。**
  * **如果迭代器使用不当，可能导致集合的修改与迭代不同步问题。**
* **适用场景：** **遍历各种数据结构（列表、树、哈希表）、统一遍历接口。**

#### 5. 中介者模式 (Mediator Pattern)

* **目的：** **用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。**
* **优点：**

  * **减少了对象之间的耦合，使得系统更易于维护和扩展。**
  * **将复杂的“多对多”通信转换为“多对一”的通信，降低了对象间的直接依赖。**
  * **集中控制交互逻辑，便于管理。**
* **缺点：**

  * **中介者自身可能成为一个“上帝对象”，承担过多的职责，变得复杂庞大。**
  * **交互集中在中介者中，可能成为系统性能瓶颈。**
* **适用场景：** **GUI 对话框（各个控件之间复杂的交互）、聊天室、航空交通管制系统、协同办公系统。**

#### 6. 备忘录模式 (Memento Pattern)

* **目的：** **在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。**
* **优点：**

  * **实现了对象的历史记录和撤销功能。**
  * **封装了对象状态，不破坏对象的封装性。**
  * **简化了原发器对象的职责。**
* **缺点：**

  * **如果需要保存的状态信息过多，会消耗大量内存。**
  * **如果原发器内部状态复杂且包含很多引用类型，深拷贝和浅拷贝问题会比较棘手。**
  * **备忘录的存取安全可能需要额外考虑。**
* **适用场景：** **文本编辑器的撤销/重做功能、游戏存档、数据库事务回滚。**

#### 7. 观察者模式 (Observer Pattern)

* **目的：** **定义对象之间的一对多依赖关系，当一个对象状态改变时，所有依赖于它的对象都会得到通知并自动更新。**
* **优点：**

  * **实现了发布-订阅模型，实现了对象之间的松散耦合。**
  * **符合“开放-封闭原则”，可以方便地增加新的观察者或主题。**
  * **支持广播通信。**
* **缺点：**

  * **如果观察者过多，通知可能成为性能瓶颈。**
  * **观察者在收到通知的顺序不确定。**
  * **如果观察者没有正确地注销自己，可能导致内存泄漏。**
* **适用场景：** **GUI 事件处理、RSS 订阅、消息队列、MVC 架构中的模型与视图分离。**

#### 8. 状态模式 (State Pattern)

* **目的：** **允许一个对象在其内部状态改变时改变它的行为。对象看起来好像修改了它的类。**
* **优点：**

  * **将复杂的条件判断逻辑分散到各个状态类中，消除了大量的 if-else 或 switch-case 语句。**
  * **使状态的转换更加明确和可维护。**
  * **符合“开放-封闭原则”，增加新状态只需添加新的状态类。**
* **缺点：**

  * **类的数量会增加，每个状态都需要一个对应的类。**
  * **对于简单状态机，可能会引入不必要的复杂性。**
* **适用场景：** **有限状态机（FSM）、TCP 连接状态、订单处理状态、游戏角色状态。**

#### 9. 策略模式 (Strategy Pattern)

* **目的：** **定义一系列算法，将它们一个个封装起来，并使它们可相互替换。策略模式让算法独立于使用它的客户而变化。**
* **优点：**

  * **消除了条件语句（if-else if / switch-case），使得代码更清晰。**
  * **实现了算法的自由切换，客户端可以在运行时选择不同的算法。**
  * **符合“开放-封闭原则”，增加新的算法无需修改现有代码。**
* **缺点：**

  * **客户端必须知道所有可用的策略，并选择合适的策略。**
  * **会创建许多小的策略类，增加了类的数量。**
  * **如果算法之间差异很小，使用该模式可能导致代码量增加。**
* **适用场景：** **排序算法、税收计算、支付方式选择、数据加密方式。**

#### 10. 模板方法模式 (Template Method Pattern)

* **目的：** **定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义该算法的某些特定步骤。**
* **优点：**

  * **代码复用性高，公共部分在父类中实现，子类只需实现具体步骤。**
  * **强制子类遵循算法的固定结构，保证了算法的正确性。**
  * **实现了“好莱坞原则”（Don't call us, we'll call you），父类控制子类的行为。**
* **缺点：**

  * **对子类的行为有较强的约束，限制了其灵活性。**
  * **增加抽象类和继承关系，系统复杂度增加。**
  * **如果算法步骤过多，模板方法可能变得难以理解和维护。**
* **适用场景：** **框架的骨架、算法的固定流程（如制作咖啡或茶的步骤）、数据处理流程。**

#### 11. 访问者模式 (Visitor Pattern)

* **目的：** **表示一个作用于某对象结构中的各元素的操作。它可以在不改变各元素的类的前提下定义作用于这些元素的新操作。**
* **优点：**

  * **可以在不修改现有元素类的情况下，为对象结构增加新的操作。**
  * **将操作代码和对象结构代码分离，符合“单一职责原则”。**
  * **可以聚合相关的操作，使其在一个访问者中完成。**
* **缺点：**

  * **增加新的元素类型比较困难，需要修改所有的访问者接口和具体访问者实现。**
  * **可能破坏了元素的封装性，因为访问者需要访问元素的内部状态。**
  * **理解和实现相对复杂，通常涉及双重分派（double dispatch）。**
* **适用场景：** **编译器（对AST的各种操作）、文件系统（文件扫描）、CAD 系统、为复杂对象结构添加新功能。**
