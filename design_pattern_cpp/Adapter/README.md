# 适配器模式 (Adapter Pattern)

**适配器模式（Adapter Pattern），也被称为**包装器（Wrapper）模式**，是结构型设计模式之一。它的主要目的是**将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作。

 **想象一下电源插座和适配器。你的电子设备是为特定类型的插座（客户期望的接口）设计的，但你身处异国，那里的插座类型（现有类的不兼容接口）不同。这时，你需要一个旅行适配器（适配器），它一端能插入当地的插座，另一端能让你的设备插入，从而实现兼容。**

## 意图

* **允许在不修改现有类源代码的情况下，使其与新的或不兼容的接口兼容。**
* **解决两个独立开发的模块之间接口不匹配的问题。**
* **通过引入一个适配器对象，将客户端请求转换成对被适配者（Adaptee）的特定请求。**

## 解决的问题

**在软件开发中，经常会遇到以下情况：**

* **你正在使用一个现有的类库或组件，但其接口与你当前系统所需的不完全匹配。**
* **你想要重用一些已有的类，但这些类的接口与你的新系统设计不兼容。**
* **你的系统需要与某个第三方库或遗留代码集成，但它们的API与你当前系统的命名约定或参数列表不一致。**

**直接修改现有类的接口往往是不切实际的，因为它可能影响到其他依赖于该接口的代码，或者你根本没有源代码修改权限（例如，第三方库）。适配器模式提供了一个优雅的解决方案，避免了这种侵入性修改。**

## 模式结构

**适配器模式通常有两种实现形式：**

### 1. 类适配器 (Class Adapter) - **基于继承**

* **目标接口 (Target):** **客户所期望的接口，适配器需要实现它。**
* **被适配者 (Adaptee):** **拥有你想要重用但接口不兼容的现有功能。**
* **适配器 (Adapter):**

  * **通过**继承**目标接口来获得客户端期望的行为。**
  * **通过**继承**被适配者来重用其功能。**
  * **因此，它既是目标接口的子类，也是被适配者的子类。**

**适用场景：**

* **当被适配者是一个具体类，且你不介意适配器继承其所有功能时。**
* **在某些语言中（如 Java），由于单继承限制，类适配器可能受限。在 C++ 中，多重继承使得类适配器成为可能。**

### 2. 对象适配器 (Object Adapter) - **基于组合/委托**

* **目标接口 (Target):** **客户所期望的接口，适配器需要实现它。**
* **被适配者 (Adaptee):** **拥有你想要重用但接口不兼容的现有功能。**
* **适配器 (Adapter):**

  * **通过**实现**目标接口来获得客户端期望的行为。**
  * **通过**组合**（持有一个被适配者对象的引用或指针）来重用被适配者的功能。**
  * **适配器将客户端的请求**委托**给其内部持有的被适配者对象。**

**适用场景：**

* **这是更常用和推荐的方式，因为它遵循**组合优于继承**的原则。**
* **当你需要适配一个接口，而不是被适配者本身的所有行为时。**
* **当你需要适配被适配者的子类时（类适配器只能适配被继承的具体类）。**
* **可以适配多个被适配者。**
* **对被适配者进行了封装，客户端无需了解被适配者的具体类型。**

## 参与者

* **目标接口 (Target):** **定义了客户端使用的特定领域接口。**
* **客户端 (Client):** **使用目标接口来与系统交互的代码。**
* **被适配者 (Adaptee):** **包含客户端所需的功能，但其接口与目标接口不兼容。**
* **适配器 (Adapter):**

  * **实现目标接口。**
  * **包含一个被适配者对象（对象适配器）或继承被适配者（类适配器）。**
  * **将客户端对目标接口的请求，转换（或委托）为对被适配者特定方法的调用。**

## 优缺点

### 优点：

* **实现接口兼容性：** **允许不兼容的接口协同工作，而无需修改它们的源代码。**
* **代码重用：** **可以重用现有的类库，避免从头开始编写功能。**
* **隔离：** **将客户端与被适配者的具体实现细节解耦。客户端只与目标接口交互。**
* **灵活性：** **对象适配器可以适配被适配者的任何子类。**

### 缺点：

* **增加复杂性：** **引入了一个新的适配器类，增加了系统的类数量和复杂性。**
* **性能开销：** **引入了一层间接性，可能（通常微不足道）增加一些性能开销。**
* **类适配器限制：** **类适配器不能适配被适配者的子类；如果被适配者是接口或抽象类，需要提供其具体实现来继承。类适配器还可能引入多重继承的复杂性。**

## 与其他模式的关系

* **装饰器模式 (Decorator Pattern):** **适配器模式改变接口，而装饰器模式增强功能。装饰器保留原始接口，适配器则提供一个不同的接口。**
* **桥接模式 (Bridge Pattern):** **桥接模式旨在将抽象与实现分离，使它们可以独立变化。适配器模式用于解决现有接口不兼容问题，通常在事后应用。**
* **外观模式 (Facade Pattern):** **外观模式为子系统提供一个简化的接口，不改变底层接口。适配器则改变一个类的接口以匹配另一个。**
* **代理模式 (Proxy Pattern):** **代理模式为另一个对象提供一个替代品或占位符，它们通常实现相同的接口。适配器则提供了不同的接口。**
