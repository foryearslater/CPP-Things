
# 备忘录模式 (Memento Pattern)

## 概述

**备忘录模式（Memento Pattern）是一种行为型设计模式。它的核心思想是**在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。

**想象一下你在使用一个文本编辑器。你可以随时保存文档的当前版本，然后继续编辑。如果后来你不满意当前的修改，可以“撤销”到之前保存的某个版本。在这里，“保存的文档版本”就是备忘录，文本编辑器是需要保存状态的对象，而编辑器的“历史记录”功能就是负责保存和管理这些备忘录的。**

## 意图

* **在不破坏对象封装性的前提下，允许对象将其内部状态保存到外部。**
* **允许对象在需要时恢复到之前保存的状态。**
* **支持撤销（undo）功能。**

## 解决的问题

**在软件开发中，我们常常会遇到以下情况：**

* **状态保存与恢复：** **一个对象（例如，一个复杂的游戏角色状态、一个编辑器的文本内容、一个图形绘制器的绘图历史）的内部状态需要被保存下来，以便在未来能够恢复到这个状态。**
* **不破坏封装：** **我们希望保存和恢复状态的功能，不应该暴露对象的所有内部实现细节，破坏其封装性。直接暴露所有内部变量来保存和加载状态是不安全的，也使得未来修改内部实现变得困难。**
* **支持撤销/重做：** **应用程序需要提供“撤销”和“重做”功能，允许用户回滚或重演操作序列。**
* **对象生命周期管理：** **需要在对象被销毁前保存其状态，以便稍后重新创建或恢复。**

**备忘录模式通过引入一个专门的“备忘录”对象来存储状态，并将状态的存取权限严格限制在原发器（需要保存状态的对象）内部，从而解决了这些问题，同时保持了良好的封装性。**

## 模式结构

**备忘录模式通常包含以下几个关键参与者：**

* **原发器 (Originator):**

  * **需要保存其内部状态的对象。**
  * **负责创建备忘录**，以保存其当前状态。
  * **负责使用备忘录**，以恢复到以前的状态。
  * **它将自己的部分或全部内部状态（通常是其私有状态）传递给备忘录对象。**
  * **它**不直接访问**或操作备忘录。**
* **备忘录 (Memento):**

  * **存储原发器在某个时刻的**内部状态**。**
  * **它的内部结构和数据通常是**私有或受保护**的，只对原发器可见（例如，通过 C++ 的** **friend** **声明，或在 Java 等语言中通过内部类）。**
  * **它提供给原发器一个宽接口（用于访问其所有状态），但提供给负责人（或其他外部对象）一个窄接口（只允许保存和检索备忘录对象，不能访问其内容）。**
  * **备忘录本身通常是**不可变的 (Immutable)**，一旦创建，其内部状态就不再改变。**
* **负责人 (Caretaker):**

  * **负责**保存和管理**备忘录对象。**
  * **它从原发器那里接收备忘录，并将其存储起来（例如，在一个栈或列表中）。**
  * **它在需要时将备忘录提供给原发器。**
  * **它**不检查备忘录的内部内容**，只把它当作一个不透明的对象。**
  * **它通常与备忘录的生命周期管理相关联。**

## 工作原理

* **保存状态：** **当原发器需要保存其当前状态时，它会创建一个新的备忘录对象，并将当前的重要内部状态数据封装到这个备忘录中，然后将备忘录返回给负责人。**
* **负责人存储：** **负责人接收到备忘录后，将其存储到其内部的集合中（例如，一个** **std::vector** **或** **std::stack**），用于历史记录或撤销功能。负责人不关心备忘录内部具体是什么，它只负责保存和弹出。
* **恢复状态：** **当原发器需要恢复到某个旧状态时，负责人从其集合中取出相应的备忘录，并将其传递给原发器。**
* **原发器恢复：** **原发器接收到备忘录后，解封备忘录，并使用备忘录中保存的数据来恢复自身的内部状态。**

**通过这种方式，原发器的内部状态被封装在它自己和备忘录内部，而负责人则保持了对状态的独立管理，实现了状态保存和恢复的机制，同时避免了对原发器内部结构的直接暴露。**

## 优缺点

### 优点：

* **不破坏封装性：** **这是备忘录模式最核心的优点。原发器的内部状态被封装在备忘录内部，外部对象（包括负责人）无法直接访问或修改原发器的内部状态，保证了数据的安全性。**
* **支持撤销/重做：** **天然适用于实现“撤销”和“重做”功能，只需将每次操作前的状态保存到历史记录中。**
* **简化原发器：** **原发器不再需要管理其历史状态，这部分职责转移给了负责人。**
* **职责分离：** **原发器负责创建和恢复状态，备忘录负责存储状态，负责人负责管理备忘录。每个角色职责单一。**

### 缺点：

* **性能和内存开销：** **如果原发器的状态非常大，或者需要保存的状态数量很多（例如，大量的历史记录），那么创建和存储备忘录可能会消耗大量的内存和时间。**
* **状态粒度问题：** **如果只需要保存部分状态，但备忘录模式通常保存整个状态，可能导致不必要的开销。**
* **生命周期管理：** **负责人需要管理备忘录对象的生命周期。在 C++ 中，如果使用裸指针，需要手动管理内存；使用智能指针则可以简化。**
* **实现复杂性：** **对于简单的情况，可能显得过于复杂。**

## 适用场景

* **当需要保存一个对象在某个时刻的内部状态，以便稍后可以恢复到这个状态时。**
* **当对象的状态需要被保存，但又不能破坏对象的封装性时。**
* **当需要提供撤销（undo）或重做（redo）功能时。**
* **当一个对象的状态变化频繁，并且需要捕获不同时间点的快照时。**
* **例如，文本编辑器中的撤销功能、游戏中的存档/读档、数据库事务的回滚点等。**

## 与其他模式的关系

* **命令模式 (Command Pattern):** **备忘录模式经常与命令模式结合使用。命令对象可以负责调用原发器的** **Save()** **方法来保存状态，或者调用** **Restore()** **方法来恢复状态，从而实现可撤销的命令。**
* **迭代器模式 (Iterator Pattern):** **如果历史记录是一个复杂的集合，可以使用迭代器模式来遍历备忘录的历史记录。**
* **快照模式 (Snapshot Pattern):** **备忘录模式是快照模式的一种实现方式，即捕获并保存对象在某个时刻的完整状态。**

## 总结

**备忘录模式是一种优雅的解决方案，用于在不破坏封装性的前提下保存和恢复对象的内部状态。它在实现撤销功能和管理对象历史状态方面非常有用。虽然可能带来一定的内存和性能开销，但其在分离职责和保持封装性方面的优势，使其成为处理复杂状态管理问题的有力工具。**
