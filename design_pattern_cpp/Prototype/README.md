
# 原型模式 (Prototype Pattern)

## 1. 意图

**原型模式**的核心意图是：**用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。**

  **简单来说，就是不再通过** **new** **关键字和一系列复杂的构造函数来创建新对象，而是找到一个**已经存在的、符合要求的对象**（即“原型”），然后**克隆**（或复制）它来获得一个状态相同的新对象。**

## 2. 动机 

**想象一下在一个游戏中，你需要生成大量的、配置相似的敌人单位。例如，在屏幕上生成 100 个“哥布林”。**

**有几个潜在问题：**

* **性能开销**：每次都通过 **new** **来创建并调用构造函数，如果** **Goblin** **对象的构造过程很复杂（比如需要从磁盘加载模型、纹理等资源），这个过程可能会非常缓慢。**
* **依赖具体类**：创建对象的代码（客户端）必须知道 **Goblin** **这个具体类的名字，并了解它的构造函数需要哪些参数。如果将来我们想把“哥布林”换成“兽人”（**Orc**），就需要修改所有创建对象的代码。**
* **状态复制复杂**：如果一个哥布林对象在游戏中经过一系列变化（比如装备升级、中了debuff），我们想创建一个与它当前状态完全一样的副本，用构造函数很难实现。

**原型模式通过“克隆”来解决这些问题。我们可以先创建一个配置好的“哥布林原型”对象。之后，每当需要一个新的哥布林时，我们不再调用** **new Goblin(...)**，而是调用 **goblinPrototype->clone()**。**clone()** **方法会负责高效地复制一个与原型一模一样的、新的哥布林实例。**

## 3. 适用场景 

**在以下情况，应当优先考虑使用原型模式：**

* **当一个对象的创建成本很高（例如，涉及数据库查询、网络请求或大量计算），而复制一个现有实例的成本较低时。**
* **当要实例化的类是在运行时动态决定的。例如，系统只需要知道所有对象都支持一个** **clone()** **接口，而无需知道它们的具体子类名称。**
* **当一个系统的产品家族有多种变体，而你希望对客户端隐藏这些产品的具体实现时。客户端只需要跟一个原型管理器打交道。**
* **当你想避免构建一个与产品类平行的工厂类层次结构时。每个产品类自己实现** **clone()** **方法，就相当于它自己就是自己的工厂。**

## 4. 结构

* **Prototype (抽象原型)**

  * **这是一个接口或抽象类，声明了一个**克隆自身的抽象方法**（通常命名为** **clone()**）。
  * **所有希望被复制的对象都必须实现这个接口。**
* **ConcretePrototype (具体原型)**

  * **这是抽象原型接口的具体实现类。**
  * **它实现了** **clone()** **方法。在这个方法内部，它知道如何创建并返回一个与自身状态完全一样的新对象。通常，这可以通过调用该类的**拷贝构造函数**来实现。**
* **Client (客户端)**

  * **客户端代码创建新对象时，不再直接实例化** **ConcretePrototype**，而是调用一个已有的原型对象的 **clone()** **方法。**
  * **客户端可以持有一个原型对象，或者从一个**原型管理器（Prototype Manager/Registry）**中根据需要获取原型。原型管理器是一个可选但非常常见的角色，它负责存储和管理一系列预先创建好的原型实例。**

## 5. 运作流程

* **客户端代码向一个原型对象请求一个自身的副本。**
* **原型对象接收到请求后，调用自身的** **clone()** **方法。**
* **clone()** **方法创建一个与自己属于同一个类的新对象。**
* **原型对象将自己所有成员变量的值，复制到新对象的对应成员变量中。**
* **clone()** **方法将这个新创建的、状态完全一样的对象返回给客户端。**

**深拷贝 vs. 浅拷贝 (Deep vs. Shallow Copy)**
这是一个在使用原型模式时必须考虑的关键问题。

* **浅拷贝**：只复制对象的成员变量的值。如果成员变量是指针，那么新旧对象的指针将指向**同一块内存地址**。修改一个对象的数据可能会意外地影响到另一个。
* **深拷贝**：除了复制值，如果遇到指针，还会为新对象**重新分配内存**，并将指针指向的内容也一并复制过去。新旧对象完全独立。

 **clone()** **方法必须根据业务需求，正确地实现深拷贝或浅拷贝**。对于大多数情况，**深拷贝**是更安全、更符合预期的选择。

## 6. 优缺点

### 优点:

* **对客户端隐藏具体类**：客户端可以复制对象而无需知道其具体类型，减少了系统中的依赖关系。
* **动态添加和移除原型**：可以在运行时通过原型管理器动态地注册新的原型对象。
* **减少子类化**：避免了为了创建不同配置对象而创建大量子类的情况，可以通过配置不同的原型实例来替代。
* **性能优势**：如果对象的创建过程比复制过程昂贵得多，原型模式可以显著提高性能。

### 缺点:

* **复杂对象的克隆可能很困难**：对于包含循环引用或复杂内部结构的对象，实现一个正确的 **clone()** **方法（特别是深拷贝）可能会非常复杂。**
* **需要为每个类实现** **clone()**: 每个希望被复制的类都需要实现克隆接口，这可能会增加一些代码量。

## 7. 与其他模式的关系

* **原型模式** **vs.** **工厂方法/抽象工厂**:

  * **工厂模式通常通过**继承**来创建不同的产品，你需要为每种产品创建一个子类工厂。**
* **原型模式则通过**委托**（复制）来创建产品。它不需要子类化，而是通过克隆预先配置好的原型实例。**
* **工厂方法经常被用作原型管理器的前端。例如，一个** **MonsterFactory** **的** **createMonster()** **方法内部，可能就是调用一个原型怪物的** **clone()** **方法。**
* **原型模式** **经常与** **组合模式 (Composite)** **和** **装饰器模式 (Decorator)** **一起使用，因为** **clone()** **方法可以方便地递归复制复杂的树状结构。**
* **单例模式 (Singleton)**: 如果将一个单例对象作为原型，那么它的 **clone()** **方法应该被特殊处理（例如，总是返回自身实例或抛出异常），因为单例的设计意图就是全局唯一。**
