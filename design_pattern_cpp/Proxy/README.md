
# 代理模式 (Proxy Pattern)

## 概述

**代理模式（Proxy Pattern）是一种结构型设计模式。它的核心思想是**为另一个对象提供一个替身（substitute）或占位符（placeholder），以控制对这个对象的访问。

**想象一下你在一个公司，需要和一位非常重要的 CEO 沟通。你通常不会直接联系 CEO，而是通过他的秘书。秘书就是 CEO 的一个代理，她接收你的请求，筛选，然后决定是自己处理、转达给 CEO，还是拒绝。通过秘书，CEO 的工作被保护起来，并且对他的访问得到了控制。**

## 意图

* **控制对另一个对象的访问。**
* **在客户端和真实对象之间引入一个间接层。**
* **在访问真实对象之前或之后执行额外的逻辑（如延迟加载、日志记录、权限控制、缓存等）。**

## 解决的问题

**在软件开发中，我们常常会遇到以下情况：**

* **资源密集型操作：** **真实对象的创建或初始化成本很高（例如，从磁盘加载大型图片、建立数据库连接、进行复杂的网络请求）。你希望只有在真正需要时才执行这些操作。**
* **权限控制：** **你需要限制或记录哪些客户端可以访问真实对象，或者在访问前进行身份验证。**
* **远程访问：** **真实对象位于不同的进程或机器上，客户端需要通过网络透明地访问它。代理可以封装网络通信的复杂性。**
* **对象生命周期管理：** **你需要在真实对象被使用之前或之后执行特定的管理操作。**
* **缓存：** **当真实对象的计算结果可以被复用时，代理可以拦截请求，提供缓存的数据，避免重复计算。**

**直接让客户端访问真实对象可能会带来性能问题、安全风险或不必要的复杂性。代理模式通过引入一个代理对象，解决了这些问题，它作为真实对象的“门卫”或“智能引用”。**

## 模式结构

**代理模式通常包含以下几个关键参与者：**

* **主题接口 (Subject Interface):**

  * **定义了真实主题和代理都应该实现的接口。**
  * **客户端通过这个接口来与真实主题或代理进行交互。这确保了代理可以无缝地替代真实主题。**
* **真实主题 (Real Subject):**

  * **实现了主题接口。**
  * **包含了客户端所需的实际功能。**
  * **通常，它的操作可能是资源密集型、耗时或敏感的。**
* **代理 (Proxy):**

  * **也实现了主题接口，使其可以被客户端视为真实主题的替代品。**
  * **包含一个指向真实主题对象的引用（组合关系）。**
  * **控制对真实主题的访问。它可以在将请求转发给真实主题之前或之后执行额外的逻辑。**
  * **可以在必要时创建或销毁真实主题对象。**
* **客户端 (Client):**

  * **通过主题接口与代理进行交互。**
  * **通常不知道自己是在与真实主题交互还是与代理交互。**

## 工作原理

* **客户端通过主题接口创建一个代理对象。**
* **客户端调用代理对象上的方法。**
* **代理对象拦截这个调用。**
* **代理在将请求转发给真实主题之前（pre-processing）或之后（post-processing）执行额外的逻辑，例如：**

  * **延迟初始化 (Lazy Initialization/Loading):** **如果真实主题尚未创建，代理会在此时创建它。**
  * **访问控制：** **检查客户端是否有权限执行操作。**
  * **日志记录：** **记录操作的开始和结束。**
  * **缓存：** **检查是否有缓存的结果，如果有则直接返回。**
  * **同步：** **如果真实对象是多线程共享的，代理可以处理同步。**
  * **引用计数：** **在某些情况下，管理真实对象的生命周期。**
* **如果需要，代理将请求转发给其内部的真实主题对象。**
* **真实主题执行实际操作并返回结果。**
* **代理可能对结果进行进一步处理，然后将其返回给客户端。**

## 代理的常见类型

* **远程代理 (Remote Proxy):** **为一个位于不同地址空间（例如，另一台服务器）的对象提供本地代理。它封装了网络通信的复杂性。**
* **虚拟代理 (Virtual Proxy):** **实现延迟加载，只有在第一次访问真实对象时才创建它。这可以提高启动性能。**
* **保护代理 (Protection Proxy):** **控制对真实对象的访问权限。根据客户端的权限，允许或拒绝操作。**
* **智能引用 (Smart Reference):** **提供额外的行为，例如在真实对象被访问时进行引用计数，或者在访问前锁定对象。**
* **缓存代理 (Caching Proxy):** **存储真实操作的结果，并在后续请求中直接返回缓存数据，避免重复昂贵的操作。**
* **日志代理 (Logging Proxy):** **记录所有对真实对象的请求。**

## 优缺点

### 优点：

* **控制访问：** **提供了对真实对象的细粒度控制，可以在访问前或后执行任何所需操作。**
* **性能优化：** **通过延迟加载、缓存等机制提高性能。**
* **安全：** **实现访问控制和权限验证。**
* **职责分离：** **将核心业务逻辑与额外的控制逻辑（如日志、安全）分离。**
* **透明性：** **由于代理和真实主题实现了相同的接口，客户端通常无需知道自己是在与代理还是真实主题交互。**

### 缺点：

* **增加复杂性：** **引入了一个新的代理类，增加了系统的类数量和复杂性。**
* **性能开销：** **引入了一层间接性，可能（通常微不足道）增加一些性能开销。**
* **可能导致误解：** **如果使用不当，可能导致客户端对真实对象的行为产生误解。**

## 与其他模式的关系

* **装饰器模式 (Decorator Pattern):**

  * **相似性：** **两者都实现了与原始对象相同的接口，并包含对原始对象的引用。**
  * **区别：** **代理模式的目的是**控制访问**（例如，延迟加载、权限）。装饰器模式的目的是**增强功能**（添加新的职责或行为）。**
* **外观模式 (Facade Pattern):**

  * **目的不同：** **外观模式旨在为**一个复杂子系统**提供一个**简化的**接口，它通常不实现子系统的接口。代理模式是**控制对单个对象**的访问，并实现相同的接口。**
* **适配器模式 (Adapter Pattern):**

  * **目的不同：** **适配器模式旨在**转换**一个不兼容的接口，使其匹配客户期望的接口。代理模式则是在不改变接口的情况下**控制访问**。**
