# 策略模式 (Strategy Pattern)

## 概述

**策略模式（Strategy Pattern）是一种行为型设计模式。它的核心思想是**定义一系列算法，将每一个算法封装起来，并使它们可以相互替换。策略模式让算法独立于使用它的客户而变化。

**想象一下一个导航应用。当你从A点到B点时，它可以提供多种路线规划方式：开车（最快路线）、步行（最短路径）、骑行（避开高速）。每种规划方式都是一种“策略”。导航应用（客户端）不关心具体的算法细节，它只是在需要时，将“路线规划”这个行为委托给当前选定的“策略”对象来完成。你可以随时切换策略，而无需改变导航应用的核心代码。**

## 意图

* **定义一系列算法（策略），将每个算法都封装起来。**
* **使算法可以在客户端之间相互替换。**
* **将算法的使用者（上下文）与算法本身（策略）解耦。**
* **允许行为在运行时被改变，而不是在编译时固定。**

## 解决的问题

**在软件开发中，我们常常会遇到以下情况：**

* **行为多样性：** **一个类（或一个功能）可能有多种不同的行为方式，这些行为方式可以相互替代。**
* **大量的条件逻辑：** **为了实现这些不同的行为，类内部可能包含大量的** **if-else if-else** **或** **switch-case** **语句，根据某些条件来选择执行哪个行为。这使得代码变得臃肿、难以阅读、维护和扩展。**
* **行为需要动态变化：** **算法或行为可能需要在运行时根据环境或用户选择进行切换。**
* **代码复用问题：** **如果多个类需要实现相似但又略有不同的行为，可能会导致代码重复。**
* **紧密耦合：** **行为与使用它的类紧密耦合，使得改变行为或引入新行为时需要修改使用它的类。**

**策略模式通过将这些可替换的行为抽象成独立的策略类，并将上下文类与具体策略解耦，从而解决了这些问题。**

## 模式结构

**策略模式通常包含以下几个关键参与者：**

* **上下文 (Context):**

  * **维护一个指向**抽象策略**对象的引用。**
  * **客户端通常与上下文交互。**
  * **它**委托（delegate）**行为到其当前持有的策略对象。**
  * **上下文不知道具体策略的细节，只知道它可以通过抽象策略接口来执行行为。**
* **抽象策略 (Strategy):**

  * **定义了一个接口，所有具体策略类都必须实现这个接口。**
  * **这个接口封装了客户端所需的行为。**
  * **它使得具体策略可以相互替换。**
* **具体策略 (Concrete Strategy):**

  * **实现抽象策略接口。**
  * **提供具体的算法或行为实现。**
  * **每个具体策略类都封装了一个特定的算法。**
* **客户端 (Client):**

  * **创建具体策略对象。**
  * **将具体策略对象设置（或注入）给上下文对象。**
  * **然后通过上下文对象来调用策略定义的行为。**

## 工作原理

* **定义策略：** **首先，定义一个抽象策略接口，以及多个实现该接口的具体策略类，每个类封装一种特定的行为或算法。**
* **注入策略：** **客户端创建上下文对象，并选择一个具体策略对象，将其设置（注入）给上下文。这个注入可以在上下文构造时完成，也可以在运行时通过** **setter** **方法完成。**
* **委托行为：** **当客户端调用上下文的某个方法时，上下文不会自己实现该方法，而是将请求**委托**给其当前持有的策略对象来执行。**
* **运行时切换：** **由于上下文只与抽象策略接口交互，客户端可以在运行时通过设置不同的具体策略对象来改变上下文的行为，而无需修改上下文的代码。**

## 优缺点

### 优点：

* **消除大量条件语句：** **彻底消除了上下文类中基于行为选择的大型** **if-else if-else** **或** **switch-case** **条件语句，使上下文的代码更简洁、更易于阅读和维护。**
* **实现算法的独立性：** **算法的实现与上下文（使用算法的类）分离，使它们可以独立地变化。**
* **遵循开放/封闭原则：** **增加新的算法（策略）时，只需创建新的具体策略类并将其注入到上下文中，无需修改上下文类或其他现有策略类。**
* **运行时行为改变：** **允许在运行时动态地切换对象的行为。**
* **提高代码复用性：** **策略可以在不同的上下文对象中复用。**

### 缺点：

* **增加类数量：** **对于每个算法，都需要创建一个新的具体策略类，这会增加类的数量，使得系统结构看起来更复杂。对于只有少量行为且行为差异不大的情况，可能显得过度设计。**
* **客户端必须知道所有策略：** **客户端需要了解所有可用的具体策略，以便选择并注入正确的策略。**
* **通信开销：** **引入了一层间接性，调用行为可能存在微小的性能开销。**
* **策略可能无状态：** **为了更好地复用，通常希望策略是无状态的（stateless），这样多个上下文实例可以共享同一个策略实例。如果策略需要状态，则需要为每个上下文创建一个策略实例。**

## 适用场景

* **当一个类有多种行为，并且这些行为可以相互替换时。**
* **当一个类的行为由大量的条件语句控制时，并且这些条件语句需要经常修改或添加新的行为时。**
* **当算法的实现细节不应该暴露给客户端时。**
* **当需要在运行时动态地选择算法或行为时。**
* **当需要避免算法的硬编码，并希望能够独立于客户端而变化时。**
* **例如，排序算法、加密算法、文件压缩算法、支付方式选择、税务计算策略等。**

## 与其他模式的关系

* **状态模式 (State Pattern):**

  * **非常相似：** **结构上几乎相同，都涉及上下文委托行为给一个实现共同接口的对象。**
  * **区别：** **策略模式关注**可替换的算法或行为**（由外部设置），它回答“我使用哪种行为？”。状态模式关注**对象行为随着内部状态的变化而变化**（通常由内部状态对象自行改变），它回答“我目前是什么状态，我应该如何行动？”。**
  * **简单来说，策略模式是**对象行为的外部改变**，而状态模式是**对象行为的内部改变**。**
* **模板方法模式 (Template Method Pattern):**

  * **相似性：** **都可以处理算法的变化。**
  * **区别：** **模板方法通过继承实现，在抽象基类中定义算法骨架，子类重写特定步骤。策略模式通过组合实现，将完整算法封装在独立对象中，上下文引用这些对象。策略模式提供了更高的运行时灵活性。**
* **工厂方法模式 (Factory Method Pattern):**

  * **可以用来创建和提供策略对象给上下文。**

## 总结

**策略模式通过将可替换的行为封装到独立的策略类中，并允许上下文在运行时动态切换策略，有效地解决了行为多样性、大量条件逻辑和行为动态变化的问题。它提升了代码的模块化、可扩展性和可维护性，是设计灵活、适应性强系统的关键工具。**
