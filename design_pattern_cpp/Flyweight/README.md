
# 享元模式 (Flyweight Pattern)

## 1. 意图 (Intent)

**享元模式**的核心意图是：**运用共享技术有效地支持大量细粒度的对象。**

  **简单来说，这个模式旨在通过**共享**那些可以在多个对象之间重复使用的、相同的、重量级的部分，来**最小化内存使用**和**提高性能。它将一个对象的状态分为两部分：可共享的**内部状态**和不可共享的**外部状态**。

## 2. 动机 (Motivation)

**想象一下，你正在开发一个大型的即时战略游戏或一个复杂的文档编辑器。**

* **游戏场景**：你需要在屏幕上同时渲染成千上万棵树、士兵或子弹。如果为每一个单位都创建一个完整的对象，每个对象都包含自己的模型、纹理、音效等重量级资源，内存会很快被耗尽。你会发现，成千上万棵“橡树”的模型和纹理数据其实是**完全一样**的，没有必要在内存中存几万份。
* **文档编辑器**：一个文档包含数百万个字符。如果为每个字符都创建一个对象，每个对象都存储自己的字体、大小、颜色等信息，同样会造成巨大的内存开销。你会发现，文档中大部分的字符都共享相同的样式（例如，正文都是“宋体，五号，黑色”）。

**享元模式正是为了解决这类问题。它建议我们将对象的状态进行划分：**

* **内部状态 (Intrinsic State)**：

  * **这是**可以被共享**的部分，它独立于对象的上下文。**
* **对于树来说，这是它的**模型网格**和**纹理**。**
* **对于字符来说，这是它的**字体**、**大小**和**颜色**。**
* **这部分数据通常是“重量级”的，且在大量对象中重复出现。**
* **外部状态 (Extrinsic State)**：

  * **这是**不可以被共享**的部分，它依赖于对象的上下文。**
* **对于树来说，这是它在地图上的**坐标 (x, y)**、**大小**和**健康值**。**
* **对于字符来说，这是它在文档中的**位置（行号、列号）**。**
* **这部分数据通常是“轻量级”的。**

 **享元模式的做法是：将**内部状态**提取出来，做成一个独立的、可共享的“享元对象”。然后，让大量的“上下文对象”只存储自己的**外部状态**，并持有一个指向共享享元对象的引用。**

## 3. 适用场景 (Applicability)

**在以下情况，应当优先考虑使用享元模式：**

* **当一个应用程序需要使用**大量的对象**时。**
* **当这些对象中的**大部分状态都可以被外部化**并共享时。**
* **当对象数量巨大，导致存储开销成为一个严重问题时。**
* **当对象的身份（地址）对于客户端来说不重要时（即客户端不关心它得到的是不是同一个共享实例）。**

**典型的应用场景包括：游戏中的粒子系统、森林渲染、UI系统中的字符和图标、网络浏览器中的DOM节点等。**

## 4. 结构 (Structure)

* **Flyweight (享元)**

  * **这是一个接口或抽象类，声明了所有享元对象必须实现的接口。**
  * **这个接口通常有一个** **operation()** **或** **draw()** **方法，它必须接收**外部状态**作为参数。**
* **ConcreteFlyweight (具体享元)**

  * **这是** **Flyweight** **接口的具体实现。**
  * **它存储了**内部状态**。**
  * **一个** **ConcreteFlyweight** **对象的实例必须是可共享的。**
* **UnsharedConcreteFlyweight (非共享具体享元)**

  * **这是一个可选的角色。并非所有** **Flyweight** **子类都需要被共享。**
  * **如果一个对象的状态（即使是内部状态）由于某种原因是唯一的，不能被共享，就可以使用这个角色。享元工厂不会将它缓存起来。**
* **FlyweightFactory (享元工厂)**

  * **这是享元模式的**核心管理者**。**
  * **它负责**创建和管理**一个享元对象的“池”（Pool）。**
  * **当客户端请求一个享元时，工厂会检查池中是否已存在一个匹配的实例。**
  * **如果存在，就返回这个已有的实例。**
  * **如果不存在，就创建一个新的实例，将其存入池中，然后返回。**
  * **这确保了具有相同内部状态的享元对象在系统中只有**一份**实例。**
* **Client (客户端)**

  * **客户端负责维护**外部状态**。**
  * **它不直接创建享元对象，而是通过**享元工厂**来获取。**
  * **当需要执行操作时，客户端会调用享元对象的** **operation()** **方法，并将自己存储的**外部状态**作为参数传递进去。**

## 5. 运作流程 (Collaborations)

* **客户端代码需要一个对象时，它会向**享元工厂**发起请求，并提供该对象所需的**内部状态**作为标识（例如，树的种类“橡树”）。**
* **享元工厂在自己的对象池中查找是否已存在一个具有相同内部状态的享元对象。**
* **如果找到了，工厂直接返回这个已有的对象。**
* **如果没有找到，工厂会创建一个新的具体享元对象，用客户端提供的内部状态来初始化它，将它存入对象池，然后返回这个新创建的对象。**
* **客户端从工厂拿到了一个共享的享元对象。**
* **客户端在需要执行操作时（例如，在屏幕上绘制一棵树），会调用享元对象的** **draw()** **方法，并将这棵树独特的**外部状态**（坐标、大小等）作为参数传递给** **draw()** **方法。**
* **享元对象利用自己存储的**内部状态**和从客户端接收到的**外部状态**，共同完成最终的操作。**

## 6. 优缺点 (Pros and Cons)

### 优点:

* **极大地节省内存**：通过共享内部状态，可以显著减少系统中对象的数量，从而大幅降低内存消耗。
* **提高性能**：减少了对象的创建和销毁开销。同时，由于内存占用降低，CPU缓存的命中率可能会提高。

### 缺点:

* **增加了代码的复杂性**：需要引入工厂、享元接口等多个角色，并将对象的状态拆分为内部和外部两部分，这使得代码的结构比直接创建对象更复杂。
* **运行时成本**：需要花费时间来查找（或计算）外部状态，并将其传递给享元对象。
* **对客户端的约束**：客户端必须自己管理外部状态，这增加了客户端的职责。

## 7. 与其他模式的关系

* **享元模式** **vs.** **组合模式 (Composite)**:

  * **享元模式经常被用来实现组合模式的**叶子节点**。例如，在一个文档的组合树中，每个字符节点都可以被实现为一个享元。**
* **享元模式** **vs.** **工厂方法/抽象工厂**:

  * **享元工厂**是实现享元模式的关键部分。它通常被实现为一个**单例（Singleton）**，以确保全局只有一个对象池。
* **享元模式** **vs.** **状态模式 (State)**:

  * **享元模式和状态模式都可以用来管理对象的状态。**
* **核心区别**：状态模式中的“状态对象”通常代表一个对象的**整体行为状态**，并且数量有限；而享元模式中的“享元对象”代表一个对象的**部分数据状态**，并且通常数量巨大。
