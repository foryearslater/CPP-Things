
# 中介者模式 (Mediator Pattern)

## 概述

**中介者模式（Mediator Pattern）是一种行为型设计模式。它的核心思想是**用一个中介对象来封装一系列对象之间的交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

**想象一下空中交通管制中心。机场塔台（中介者）负责协调所有进出港飞机（具体同事对象）的起降、滑行、飞行路径。飞机之间不需要直接通信，它们只需要和塔台通信。塔台收到信息后，根据规则协调其他飞机的行为。这大大降低了飞机之间直接通信的复杂性，并且塔台可以灵活地改变调度策略而无需修改飞机本身。**

## 意图

* **用一个中介对象来封装多个对象之间的复杂交互逻辑。**
* **减少对象之间的直接通信，从而降低耦合度。**
* **集中管理和控制对象之间的通信行为。**
* **促进对象之间更松散的耦合，使它们可以独立变化。**

## 解决的问题

**在软件开发中，我们常常会遇到以下情况：**

* **对象间直接通信复杂且紧密耦合：** **系统中许多对象之间需要直接相互引用并通信，形成网状结构（“意大利面条式代码”）。这使得修改任何一个对象的行为都可能牵一发而动全身，系统变得难以理解、测试和维护。**
* **依赖关系复杂：** **一个对象的行为依赖于多个其他对象的行为，导致对象具有多个指向其他对象的引用。**
* **行为重用困难：** **某些行为散布在多个对象中，难以提取和重用。**
* **难以扩展：** **每当添加新对象或改变现有对象行为时，都需要修改与其关联的所有对象。**

**中介者模式通过引入一个**中介者（Mediator）**对象，解决了这些问题。中介者充当了所有相关对象之间的中央通信枢纽。对象不再直接相互通信，而是通过中介者进行通信。**

## 模式结构

**中介者模式通常包含以下几个关键参与者：**

* **抽象中介者 (Mediator Interface):**

  * **定义了一个抽象接口，用于同事对象（Colleague）与中介者通信。**
  * **通常包含一个** **Notify()** **或** **HandleEvent()** **等方法，供同事对象在状态改变时通知中介者。**
* **具体中介者 (Concrete Mediator):**

  * **实现抽象中介者接口。**
  * **知道并维护它所管理的**所有同事对象**的引用。**
  * **封装了所有同事对象之间的交互逻辑。** **它负责接收同事对象的通知，并根据业务规则协调其他同事对象的行为。**
* **抽象同事 (Colleague Interface - 可选):**

  * **定义了同事对象与中介者交互的通用接口。**
  * **通常包含一个指向其所属中介者的引用。**
  * **在我们的示例中，**UIComponent **就是这样的抽象同事。**
* **具体同事 (Concrete Colleague):**

  * **实现抽象同事接口。**
  * **不再直接与任何其他同事对象通信。**
  * **当自身状态改变或需要与其他同事交互时，它会**通知其所属的中介者**。它只知道中介者，而不知道其他同事的存在。**

## 工作原理

* **同事注册：** **在系统初始化时，所有相关的同事对象都会创建并注册（或在构造函数中被传递）到具体中介者中。同时，每个同事对象也会被告知它所属的中介者是谁。**
* **同事通知：** **当一个具体同事对象的状态发生变化，或者需要与其他同事协作时，它会调用其所属中介者的** **Notify()** **方法，并把自己（**this **指针）和发生的事件作为参数传递给中介者。**
* **中介者协调：** **具体中介者收到通知后：**

  * **它会识别出是哪个同事对象触发了通知以及发生了什么事件。**
  * **根据预定义的业务逻辑，中介者会调用一个或多个其他同事对象的方法，来协调它们的行为，以响应最初的通知。**
* **无直接引用：** **任何同事对象都不知道其他同事的存在，它们只知道中介者。这样，所有对象间的复杂交互逻辑都被集中封装在中介者内部。**

## 优缺点

### 优点：

* **降低耦合度：** **最重要的优点。它将原本复杂的网状交互结构转换为星形结构。同事对象之间不再直接相互引用，而是通过中介者进行通信，从而大大降低了它们之间的耦合度。**
* **职责集中：** **将对象间的协作逻辑从各个对象中剥离出来，集中到中介者中。这使得协作逻辑更易于理解、维护和修改。**
* **促进独立变化：** **同事对象可以独立地变化而不会影响到其他同事对象，因为它们的交互都被中介者封装了。**
* **提高可重用性：** **独立于其他同事的同事对象更易于重用。**
* **简化单个组件：** **每个组件的逻辑只关注自身行为，而无需管理与其他组件的复杂依赖。**

### 缺点：

* **中介者可能演变为“上帝对象”：** **如果系统中对象间的交互非常复杂，中介者可能会变得非常庞大和复杂，难以理解和维护，成为一个“上帝对象”（God Object）。**
* **增加间接性：** **引入了一层间接性，所有的通信都必须通过中介者，这可能导致轻微的性能开销，并增加一些调试的难度。**
* **难以测试中介者：** **如果中介者包含大量复杂逻辑，且与许多同事对象耦合，测试中介者本身可能会变得困难。**

## 适用场景

* **当系统中对象之间存在复杂且难以管理的网状交互关系时。**
* **当一个对象的行为会影响到许多其他对象，并且这种影响方式是动态的或复杂的时。**
* **当对象之间的协作逻辑需要被集中管理和控制，而不是分散在各个对象中时。**
* **当需要解耦多个组件，使它们可以独立变化和重用时。**
* **常见的应用包括：GUI 框架中的对话框、工作流引擎、聊天室系统、控制器等。**

## 与其他模式的关系

* **观察者模式 (Observer Pattern):**

  * **相似性：** **都可以实现对象间的通信。中介者可以利用观察者模式来通知其管理的同事对象。**
  * **区别：** **观察者模式是“一对多”的广播式通信，发送者不关心谁接收。中介者模式是“多对多”的集中协调，中介者知道并控制谁与谁通信。中介者更侧重于**协调**，而观察者更侧重于**通知**。**
* **外观模式 (Facade Pattern):**

  * **相似性：** **都隐藏了复杂性。**
  * **区别：** **外观模式旨在为**一个复杂子系统**提供一个**简化的**接口，它是“自上而下”的简化。中介者模式旨在简化**子系统内部组件之间**的直接交互，它是“水平”的解耦和协调。**
* **组合模式 (Composite Pattern):** **UI 组件通常会形成组合结构，中介者可以与这些组合结构交互。**
