
# 装饰器模式 (Decorator Pattern)

## 1. 意图 (Intent)

**装饰器模式**的核心意图是：**动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。**

**简单来说，这个模式允许你像“套娃”或者“穿衣服”一样，在运行时将一个或多个功能（装饰器）包裹在一个基础对象上，从而扩展其行为，而无需修改这个对象的代码，也无需创建大量的子类来应对各种功能组合。**

## 2. 动机 (Motivation)

**想象一下，你正在开发一个图形界面的UI库。你有一个基础的** **TextView** **组件，它只能显示纯文本。现在，客户提出了新的需求：**

* **需要能给** **TextView** **添加**边框 (Border)**。**
* **需要能给** **TextView** **添加**滚动条 (Scrollbar)**。**
* **更复杂的是，需要一个**既有边框又有滚动条**的** **TextView**。

**如果使用传统的继承方式，你可能会创建出这样的类继承体系：**

* **TextViewWithBorder** **(继承自** **TextView**)
* **TextViewWithScrollbar** **(继承自** **TextView**)
* **TextViewWithBorderAndScrollbar** **(这个继承关系变得复杂和混乱)**

**如果再增加一个新的功能，比如“背景阴影”，类的数量就会爆炸式增长（**TextViewWithShadow**,** **TextViewWithBorderAndShadow**, **TextViewWithScrollbarAndShadow**, **TextViewWithAllThree**...）。这种**“类爆炸”**问题使得系统难以维护和扩展。

**装饰器模式通过**组合**而非继承来解决这个问题。它的思路是：**

* **创建一个基础的** **TextView** **对象。**
* **如果需要边框，就创建一个** **BorderDecorator** **对象，并让它“**包裹**”住** **TextView** **对象。**
* **如果还需要滚动条，就再创建一个** **ScrollbarDecorator** **对象，让它“**包裹**”住那个已经被** **BorderDecorator** **包裹过的对象。**

**最终你得到一个像** **ScrollbarDecorator(BorderDecorator(TextView))** **这样的“套娃”结构。当客户端调用最外层** **ScrollbarDecorator** **的** **draw()** **方法时，它会先绘制滚动条，然后调用被它包裹的** **BorderDecorator** **的** **draw()** **方法；**BorderDecorator **会先绘制边框，然后调用最里面的** **TextView** **的** **draw()** **方法。**

**这样，功能的添加和组合变得非常灵活，可以在运行时动态决定。**

## 3. 适用场景 (Applicability)

**在以下情况，应当优先考虑使用装饰器模式：**

* **当你希望在**不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责**时。**
* **当你需要处理的职责可以被**动态地撤销**时（例如，移除一个装饰器）。**
* **当使用**子类继承来进行扩展会导致类的数量不受控制地增长**时（类爆炸）。**
* **当一个对象的定义是隐藏的，或者由于其他原因**无法通过继承来扩展**时。**

## 4. 结构 (Structure)

**装饰器模式通常包含以下四个核心角色：**

```
![alt text](https://refactoring.guru/images/patterns/diagrams/decorator/structure.png)
```

(图片来源: refactoring.guru)

* **Component (组件)**

  * **这是一个接口或抽象类，定义了**原始对象**和**装饰器对象**的**统一接口**。**
  * **客户端代码将通过这个接口与所有被包装的对象进行交互。**
  * **例如，**GraphicComponent **接口，定义了** **draw()** **方法。**
* **ConcreteComponent (具体组件)**

  * **这是实现了** **Component** **接口的、可以被装饰的**基础对象**。**
  * **它是装饰链的**起点和核心**。**
  * **例如，**TextView**。**
* **Decorator (抽象装饰器)**

  * **这也是一个实现了** **Component** **接口的抽象类。**
  * **核心特征**：它内部**包含**一个指向另一个 **Component** **对象的引用或指针。这个指针就是它所“包裹”的对象。**
  * **它将所有来自客户端的请求**委托**给被它包裹的** **Component** **对象。**
  * **它是所有具体装饰器的基类。**
* **ConcreteDecorator (具体装饰器)**

  * **这是** **Decorator** **的具体实现。**
  * **它负责为被包裹的** **Component** **对象**添加新的职责**。**
  * **它通常会重写** **Component** **的方法，在调用父类（即被包裹对象）的同一个方法**之前或之后**，执行自己的附加操作。**
  * **例如，**BorderDecorator **和** **ScrollbarDecorator**。

## 5. 运作流程 (Collaborations)

* **客户端代码创建一个**具体组件（ConcreteComponent）**对象。**
* **然后，客户端根据需要，用一个或多个**具体装饰器（ConcreteDecorator）**对象来层层包裹这个组件。**
* **每个装饰器在创建时，都会接收它要包裹的那个对象（可以是一个具体组件，也可以是另一个已经被装饰过的对象）作为参数。**
* **客户端通过统一的**组件（Component）**接口，调用最外层的那个装饰器的方法（例如** **decoratedObject->operation()**）。
* **这个请求会像链条一样，从最外层的装饰器开始，向内层传递。每个装饰器在将请求传递给它内部包裹的对象之前或之后，执行自己的附加功能。**
* **最终，请求会到达最核心的具体组件对象，完成基础操作。**

## 6. 优缺点 (Pros and Cons)

### 优点:

* **高度的灵活性**：比静态继承更灵活。你可以在运行时添加或移除任意数量的职责。
* **避免类爆炸**：可以用少量的装饰器类，实现大量的功能组合，有效地避免了因功能组合而创建大量子类的问题。
* **单一职责原则**：每个装饰器类只负责一项特定的功能，使得代码结构更清晰。
* **符合开闭原则**：你可以在不修改现有组件或装饰器代码的情况下，引入新的具体装饰器来增加新功能。

### 缺点:

* **产生大量小对象**：使用装饰器模式可能会在系统中产生许多功能单一的小对象，这可能会使配置和管理变得复杂。
* **增加了代码的间接性**：装饰链条可能会很长，使得代码的调试和理解变得困难，不容易一眼看出一个对象的最终行为。
* **初始化过程复杂**：创建一个被多层装饰的对象，其初始化代码可能会比较繁琐（例如 **new C(new B(new A()))**）。

## 7. 与其他模式的关系

* **装饰器模式** **vs.** **适配器模式 (Adapter)**:

  * **两者都是“包装器”。**
* **核心区别**：适配器旨在**改变**一个对象的接口，使其与其他不兼容的接口协同工作；而装饰器旨在**增强**一个对象的职责，它**不改变**对象的接口。
* **装饰器模式** **vs.** **组合模式 (Composite)**:

  * **两者都使用了递归组合的结构。**
* **核心区别**：装饰器为对象**添加**功能，通常只包装一个对象；组合模式则**聚合**一组对象，代表一个“部分-整体”的层次结构。
* **装饰器模式** **vs.** **策略模式 (Strategy)**:

  * **两者都可以用来改变一个对象的行为。**
* **核心区别**：装饰器改变的是一个对象的“**皮肤**”，在外部添加功能；策略模式则改变一个对象的“**内在**”，通过替换其内部的一个算法对象来改变行为。
