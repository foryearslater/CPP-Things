# 字节跳动面经整理

## 1.code:

    46:全排列

    [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

    124.二叉树最大路径和

    19.删除链表的倒数第-n-个结点

    56.合并区间

    415.字符串相加

    92.反转链表-ii


# 字节tiktok国际电商面试总结：

问到了个人项目，可能对redis讲解没讲好，表达不够逻辑舒畅

#### 1. Linux上线程之间同步方案？

**在 Linux 环境中，线程同步主要有以下几种方式：**

* **互斥锁 (Mutex)**：通过锁定机制，确保在同一时间只有一个线程能够访问被保护的资源。
* **条件变量 (Condition Variable)**：通常与互斥锁一同使用，它允许线程在特定条件未满足时进入等待状态，直到其他线程改变了该条件并发出通知。
* **信号量 (Semaphore)**：用于控制对共享资源的并发访问数量，可以允许多个线程同时访问一个资源，但会限制最大并发数。
* **读写锁 (Read-Write Lock)**：这种锁允许多个线程同时进行读操作，但在任何线程进行写操作时，会独占资源，从而实现读共享、写独占的访问控制。

#### 2. 进程间同步方式？

**进程间的同步（也是进程间通信，IPC 的一部分）主要通过以下方式实现：**

* **管道 (Pipe)**：包括匿名管道和命名管道，它们提供了一种半双工的通信方式，数据只能单向流动。
* **信号 (Signal)**：是 Linux 系统中用于进程间传递异步事件的一种机制。
* **信号量 (Semaphore)**：与线程信号量类似，但作用于不同进程之间，用于控制对共享资源的访问。
* **消息队列 (Message Queue)**：允许进程以消息的形式进行通信，这些消息被存储在内核的一个队列中，直到被接收进程读取。
* **共享内存 (Shared Memory)**：这是最快的 IPC 方式，它允许多个进程直接访问同一块内存空间，但需要额外的同步机制（如互斥锁、信号量）来保证数据的一致性。
* **套接字 (Socket)**：是一种更为通用的 IPC 机制，不仅可以用于同一台机器上的进程间通信，还可以用于不同机器间的网络通信。

#### 3. 共享内存有没有了解过系统是怎么实现的？

**共享内存的实现依赖于操作系统的虚拟内存管理机制。其基本原理是：**

* **一个进程在内存中创建一个共享内存段。**
* **其他希望访问这个内存段的进程需要先将它“挂载”到自己的虚拟地址空间中。**
* **操作系统通过页表映射，将不同进程的虚拟地址指向同一块物理内存区域。这样，当一个进程向这块内存写入数据时，其他进程就能够立刻看到这些变化，因为它们实际上操作的是同一块物理内存。**

#### 4. 你有在项目中用过 mmap 吗？ 有哪些场景会考虑使用 mmap？

**mmap** **(memory-mapped file) 是一种将文件或其他对象映射到进程地址空间的技术。在以下场景中，可以考虑使用** **mmap**：

* **大文件读写**：对于需要频繁读写的大文件，**mmap** **可以显著提升 I/O 性能。**
* **进程间通信**：通过将同一个文件映射到不同进程的地址空间，可以实现高效的共享内存式通信。
* **动态内存分配**：在某些情况下，**mmap** **也可以被用作一种动态分配内存的方式。**

#### 5. 大文件用 mmap 映射读，为什么可以减少拷贝次数？ 直接用 read 系统调用会发生几次拷贝？ mmap 会拷贝几次？

**使用** **mmap** **之所以能减少数据拷贝，是因为它利用了操作系统的虚拟内存和缺页中断机制。**

* **传统** **read** **系统调用的拷贝过程**：

  * **第一次拷贝**：数据从硬盘被 DMA（直接内存访问）拷贝到内核空间的页缓存 (page cache) 中。
* **第二次拷贝**：数据从内核空间的页缓存被 CPU 拷贝到用户空间的缓冲区 (buffer) 中。
  因此，传统的 **read** **方式至少涉及两次数据拷贝。**
* **mmap** **的过程**：
  mmap **将文件直接映射到用户空间的虚拟地址，实现了所谓的“零拷贝”技术。当应用程序访问这段内存时，如果对应的数据不在物理内存中，会触发一个缺页中断。此时，内核才会将文件数据从硬盘通过 DMA 直接加载到物理内存（同时作为页缓存），然后应用程序就可以直接访问这块内存了，整个过程省去了从内核空间到用户空间的数据拷贝。因此，可以说** **mmap** **实现了零次 CPU 数据拷贝。**

#### 6. 除了减少拷贝次数，mmap 还有其他优势吗？

**除了核心的“零拷贝”优势外，**mmap **还具备以下优点：**

* **简化的文件操作**：将文件映射到内存后，可以像操作普通内存数组一样直接通过指针进行读写，无需调用 **read()** **或** **write()** **等系统调用。**
* **内存共享**：多个进程可以映射同一个文件，从而高效地共享数据。

#### 7. 管道使用过程中有什么注意点吗？ 特别容易出错的？ 用错后会有很大的危害的？

**使用管道时需要注意以下几点，这些也是容易出错的地方：**

* **读写阻塞**：

  * **当管道为空时，读操作会阻塞，直到有数据被写入。**
* **当管道已满时，写操作会阻塞，直到有数据被读出。**
* **读写端关闭问题**：

  * **如果所有写端都已关闭，而此时仍有进程尝试从管道读取数据，那么它将读到文件结束符 (EOF)。**
* **如果所有读端都已关闭，而此时仍有进程尝试向管道写入数据，该进程会收到一个** **SIGPIPE** **信号，程序的默认行为是终止。**
* **危害**：

  * **死锁**：如果进程在读写管道时处理不当，例如一个进程等待从一个空管道读取数据，而另一个进程等待向一个满管道写入数据，就可能导致两个进程相互等待，形成死锁。
* **程序异常退出**：如上所述，在读端关闭后进行写操作会导致程序因 **SIGPIPE** **信号而终止。**

#### 8. 项目中中正式用到管道吗？

**这是一个针对您个人项目经验的问题，您需要根据自己的实际情况来回答。例如，您可以回答：“在 xxx 项目中，我使用了匿名管道来实现父子进程间的单向通信，具体用于...”**

#### 9. 项目中有用过信号吗？

**同样，这是一个针对您个人项目经验的问题。您可以回答：“是的，在 xxx 项目中，我使用了** **SIGINT** **信号来优雅地关闭服务器，确保在程序终止前能够释放资源并保存状态。”**

#### 10. 举个例子介绍一下如何实现信号屏蔽过程？

**信号屏蔽是指暂时阻止某个信号被进程接收和处理。下面是一个使用** **sigprocmask** **函数屏蔽** **SIGINT** **信号的示例过程：**

* **定义信号集**：创建一个 **sigset_t** **类型的变量，用于存储需要屏蔽的信号。**
* **清空并添加信号**：使用 **sigemptyset** **清空信号集，然后使用** **sigaddset** **将** **SIGINT** **信号添加到该集合中。**
* **设置屏蔽**：调用 **sigprocmask** **函数，并使用** **SIG_BLOCK** **参数来将新定义的信号集添加到进程的当前信号屏蔽字中。**
* **执行临界区代码**：在这段代码执行期间，即使接收到 **SIGINT** **信号（例如通过 Ctrl+C），该信号也会被阻塞，不会中断程序的执行。**
* **解除屏蔽**：再次调用 **sigprocmask** **函数，并使用** **SIG_UNBLOCK** **参数来从进程的信号屏蔽字中移除** **SIGINT**，使其可以被正常处理。

#### 11. C++异常机制是怎么实现的？ 底层原理连续深挖（catch捕捉、栈展开等）

 **C++ 的异常处理机制是一个相当复杂但设计精巧的系统，其核心是**栈展开（Stack Unwinding）**。**

* **当** **throw** **表达式被执行时，程序的正常执行流程会被中断。**
* **接下来，异常处理机制开始沿着函数调用栈向后“展开”，寻找一个能够处理该类型异常的** **catch** **块。**
* **在栈展开的过程中，每退出一个函数的作用域，该函数内创建的所有局部对象（栈上对象）都会被自动销毁，它们的析构函数会被依次调用。这个过程保证了即使在异常发生的情况下，资源也能够被正确释放（这也是 RAII，资源获取即初始化，模式的核心）。**
* **一旦找到了匹配的** **catch** **块，程序的控制权就转移到该** **catch** **块，并从那里继续执行。**

#### 12. 怎么实现的栈展开？ 实现栈资源清理？

**栈展开的实现通常依赖于编译器和操作系统。编译器在编译代码时，会为可能抛出异常的函数生成一些额外的信息，这些信息通常存储在可执行文件的一个特定区域（例如，**.eh_frame **段）。**

* **栈展开信息**：这些信息精确地描述了在程序的每个执行点上，栈的布局是怎样的，以及如何销毁当前栈帧上的局部对象。
* **资源清理**：当异常被抛出时，运行时库中的一个特殊函数（通常称为“个性化例程”）会利用这些预先生成的信息。它会逐个栈帧地回溯，对于每个栈帧，它会查找并调用所有局部对象的析构函数，从而完成资源的清理。

#### 13. 如果没有 catch，上面的栈帧会展开吗？

**是的，会的。**
如果异常抛出后，在整个函数调用链上都找不到与之匹配的 **catch** **块，栈展开的过程仍然会发生。它会一直展开到** **main** **函数的调用者。在这个过程中，所有已创建的局部对象的析构函数都会被调用。最终，因为没有找到合适的处理器，程序会调用** **std::terminate** **函数，导致程序异常终止。**

#### 14. throw 时的代码可能是 clang 的代码？ 上一帧代码可能是 gcc 的代码，他是怎么实现栈展开、栈资源清理的？

**这是一个关于 C++ ABI（应用程序二进制接口）兼容性的问题。为了让由不同编译器（如 GCC 和 Clang）编译的代码能够相互链接和调用，它们需要遵循一个共同的 ABI 标准。**

* **在 Linux 系统上，GCC 和 Clang 等现代 C++ 编译器普遍遵循** **Itanium C++ ABI**。
* **这个 ABI 标准详细规定了异常处理的实现细节，包括如何生成栈展开信息、异常对象如何在栈上传递、以及个性化例程如何工作等。**
* **正是因为遵循了同一个 ABI 标准，由 Clang 编译的代码抛出的异常，才能够被由 GCC 编译的代码中的** **catch** **块正确捕获，并且整个栈展开和资源清理的过程能够跨越不同编译器生成的代码边界而无缝进行。**

#### 15. C++中将一个对象资源进行移动的话，有哪些注意事项？

**在 C++ 中通过移动语义（Move Semantics）来转移对象资源时，需要注意以下几点：**

* **确保源对象处于有效但未指定的状态**：在移动操作（通过移动构造函数或移动赋值运算符）完成后，被移走的源对象必须仍然是一个有效的对象，可以被安全地析构。虽然它的具体状态是未定义的，但它必须满足其类的基本不变性。
* **正确处理自赋值**：在实现移动赋值运算符时，需要检查并正确处理自我赋值的情况（即 **x = std::move(x)**），以防止对象意外地销毁自己的资源。
* **noexcept** **关键字**：如果移动操作保证不会抛出任何异常，应该将其标记为 **noexcept**。这对于标准库容器的性能至关重要，因为容器在进行某些操作（如 **std::vector** **的扩容）时，会检查移动构造函数是否为** **noexcept**，如果是，才会使用移动语义；否则，为了保证强异常安全，它会退而求其次使用拷贝语义。
* **避免使用被移走的源对象**：在资源被移走后，除非重新对它赋值，否则不应该再使用这个源对象的值，因为它的状态是未知的

### C++ 相关

#### 16. 自己的类中是否重写过移动构造函数或者移动赋值操作符？

**这是一个考察实际编程经验的问题，您需要根据自己的项目经历来回答。一个好的回答可以参考如下结构：**

**“是的，在我负责开发的 XX 模块中，我为一个名为** **ResourceWrapper** **的类重写了移动构造函数和移动赋值操作符。这个类封装了一个大的内存缓冲区和文件句柄。为了在函数返回或者容器扩容时，能够高效地转移这些资源的所有权，而不是进行昂贵的深拷贝，我实现了移动语义。这显著提升了涉及该对象传递时的性能。”**

#### 17. 如果要写一个移动赋值操作符，有没有一些坑的存在？

**是的，编写移动赋值操作符时有几个常见的“坑”需要注意：**

* **自我赋值 (Self-assignment)**：虽然移动赋值的自我赋值（**x = std::move(x)**）是一种不常见的用法，但一个健壮的实现应该能够正确处理它。最简单的处理方式是在操作符的开头加上 **if (this != &other)** **的判断。**
* **资源泄露**：在获取新资源之前，必须先正确地释放当前对象所拥有的旧资源。
* **源对象的状态**：移动操作完成后，源对象（被移走的那个对象）必须处于一个**有效但未指定 (valid but unspecified)** **的状态。这意味着这个对象仍然可以被安全地析"构，或者被重新赋值，但不应该再对其原有的值做任何假设。例如，一个被移走的** **std::vector** **的状态不能被假定，但它必须是可析构的。**

#### 18. 为什么要加 noexcept 关键字？ 它是如何做到可以调用不同构造函数的？

 **为移动操作（移动构造函数和移动赋值运算符）添加** **noexcept** **关键字至关重要，主要原因是为了**获得标准库容器的性能优化**。**

* **原因**：标准库的许多容器（如 **std::vector**）在需要重新分配内存（例如扩容）时，需要将旧内存中的元素移动到新内存。为了提供**强异常安全保证** **(strong exception guarantee)，即如果操作因异常而失败，程序状态会回滚到操作开始之前的状态。**
* **如果元素的移动构造函数是** **noexcept** **的，容器就知道移动元素不会抛出异常。因此，它可以安全地、逐个地将元素“移动”到新内存区域。**
* **但如果移动构造函数**没有**被标记为** **noexcept**，容器就无法假设移动操作是安全的。万一在移动第 N 个元素时抛出异常，前面的 N-1 个元素已经被移动，而后面的元素还在老地方，此时状态已经损坏，无法回滚。为了保证强异常安全，容器会退而求其次，选择**拷贝构造函数**来代替，因为拷贝操作不会改变源对象，即使失败了也能保持原始状态。
* **如何做到调用不同函数**：这不是 **noexcept** **关键字本身的功能，而是标准库通过模板元编程（SFINAE）和类型萃取（type traits）实现的。例如，标准库中有一个工具** **std::move_if_noexcept**。它会检查其参数的移动构造函数是否为 **noexcept**。

  * **如果是，**std::move_if_noexcept **会返回一个右值引用，触发移动操作。**
* **如果不是，它会返回一个左值引用，从而触发拷贝操作。**
  容器内部正是利用了类似这样的机制来决定是调用移动构造函数还是拷贝构造函数。20. 假如目前有个 c 文件写了简单的 printf("hello, world!") 这个过程，能解释下这个文件从源码到最终在屏幕上显示出来这个过程吗？

 **这个过程可以分为四个主要阶段：**编译、链接、加载和执行**。**

 **阶段一：编译 (Compilation)**
当你执行 **gcc hello.c -o hello** **时，编译器会将 C 语言源码（人类可读的文本）转换成机器码（CPU 可执行的指令）。这个阶段内部又分为：**

* **预处理 (Preprocessing)**：处理 **#include**、**#define** **等指令。例如，**#include <stdio.h> **会被替换为** **stdio.h** **文件的实际内容。**
* **编译 (Compilation)**：将预处理后的代码翻译成汇编代码 (**.s** **文件)。**
* **汇编 (Assembly)**：将汇编代码转换成机器码，并打包成一个可重定位目标文件 (**.o** **文件)，此时文件中包含了代码段、数据段等。但是，像** **printf** **这样的函数地址还是未知的，只是一个符号。**

**阶段二：链接 (Linking)**

#### 21. 链接具体会做什么事情？

**链接器的任务是将多个目标文件（比如我们自己写的** **hello.o** **和 C 语言标准库** **libc**）合并成一个单一的可执行文件。其核心工作是：

* **符号解析 (Symbol Resolution)**：编译器在编译 **hello.c** **时，并不知道** **printf** **函数的地址在哪里。链接器会在其他目标文件或库文件中查找这个符号的定义。在这个例子中，它会在 C 标准库中找到** **printf** **的实现。**
* **重定位 (Relocation)**：链接器一旦找到了 **printf** **的地址，就会将代码中所有调用** **printf** **的地方都更新为这个真实的地址。它还会合并所有输入文件的相同段（如** **.text** **段、**.data **段），并为它们分配运行时的内存地址。**

**阶段三：加载 (Loading)**

#### 24. 比如你的文件时 a.out，a.out 运行的过程加载的过程是怎样的？ a.out 是谁加载的？ 加载是怎么加载的？

* **启动**：当你在 shell 中输入 **./hello** **并回车时，shell 会调用** **execve** **这个系统调用。**
* **内核介入**：**execve** **会使操作系统内核接管控制权。内核会执行以下操作：**

  * **检查文件权限和格式（例如，确认它是一个有效的 ELF 可执行文件）。**
* **创建一个新的虚拟地址空间（包括栈、堆等）。**
* **加载**：读取可执行文件的头部信息，根据其中的段描述（Program Headers），将文件的代码段（**.text**）和数据段（**.data**）映射（**mmap**）到新的虚拟地址空间中。

**阶段四：执行 (Execution) 与动态链接**

#### 26. 动态链接器是什么时候接入的？

#### 23. 动态链接器是怎么知道我的可执行程序依赖于哪些动态库？

#### 22. 动态链接在运行时怎么去知道要去查找什么库呢？

* **动态链接器介入**：如果程序是动态链接的（现代系统上几乎都是），内核在加载完程序本身后，并不会立即把控制权交给程序的 **main** **函数。它会检查可执行文件中的一个特殊段** **.interp**，这个段里包含了**动态链接器**的路径（在 Linux 上通常是 **/lib64/ld-linux-x86-64.so.2**）。内核会先加载并运行这个动态链接器。
* **依赖解析**：动态链接器接管控制权后，会读取可执行文件的 **.dynamic** **段。这个段里包含了一系列条目，其中** **DT_NEEDED** **条目就列出了该程序所依赖的所有共享库（例如** **libc.so.6**）。
* **库的加载**：动态链接器会根据 **DT_NEEDED** **列表，在预设的路径（如** **/etc/ld.so.conf** **中指定的路径、**/lib**、**/usr/lib **等）中查找并加载所有需要的共享库，同样使用** **mmap** **将它们映射到进程的虚拟地址空间。**
* **运行时重定位**：加载完所有库后，动态链接器会再次进行重定位。它会解析程序中对共享库函数的引用（比如 **printf**），并用这些函数在内存中的实际地址来填充程序的**全局偏移表 (GOT)**。

#### 24. (续) 怎么执行到 main 函数？ printf 是怎么调起来的？ "hello world" 是怎么输出的屏幕上的？

* **跳转到** **main**：动态链接器完成所有初始化工作后，会将控制权转交给可执行文件自身的入口点（通常是一个名为 **_start** **的函数，而不是** **main**）。**_start** **是由 C 运行时库 (CRT) 提供的，它会进行一些环境设置（比如准备** **main** **函数的参数** **argc** **和** **argv**）。

  * #### 25. main 函数中的一些参数是谁来获取的？

  **argc**、**argv** **这些参数是内核在启动程序时就放入了进程的栈顶。**_start **函数会从栈上获取这些信息，然后将它们作为参数传递给** **main** **函数。**
* **调用** **main**：最后，**_start** **会调用** **main** **函数，我们的程序代码才真正开始执行。**
* **调用** **printf**：当 **main** **函数调用** **printf** **时，由于是动态链接，它实际上会跳转到**过程链接表 (PLT) **中的一小段代码。这段代码会查询 GOT 表来找到** **printf** **的真实地址。如果是第一次调用，GOT 表中没有地址，PLT 代码会再次调用动态链接器来查找** **printf** **的地址并填充到 GOT 表中，之后再跳转过去。后续的调用则可以直接从 GOT 表获取地址，直接跳转。**
* **输出到屏幕**：

  #### 27. printf 是怎么实现的？

  **printf** **函数内部会解析格式化字符串** **"hello, world!"**，并将这个字符串写入到一个与**标准输出 (stdout)** **相关联的**缓冲区**中。**
* **当缓冲区满、遇到换行符或程序结束时，**printf **最终会调用** **write** **系统调用，请求内核将缓冲区中的数据（"hello, world!"）写入到标准输出所对应的文件描述符（通常是 1）中。**
* **内核接收到** **write** **请求后，会通过设备驱动程序（与你的终端或显示器相关联），最终将这些字符数据显示在屏幕上。**

#### 28. 全局变量的构造函数是在什么时候调用的？ 由谁调用？

**全局变量（以及静态变量）的构造函数是在** **main** **函数执行之前**调用的。这个调用过程是由 C 运行时库的入口函数 (**_start**) 在调用 **main** **之前安排和执行的。编译器会在可执行文件中创建一个特殊的函数列表（通常在** **.init_array** **段），**_start **会遍历这个列表并执行其中的每一个函数指针，从而完成所有全局/静态对象的构造。**

#### 29. 有哪些方式能够实现在程序退出之前执行某些特定的操作？ (多种方案)

**有多种方式可以在程序正常退出前执行收尾工作：**

* **使用** **atexit()** **函数**：可以注册一个或多个函数，这些函数会在 **main** **函数返回或调用** **exit()** **时，以与注册时相反的顺序被自动调用。**
* **全局/静态对象的析构函数**：利用 RAII（资源获取即初始化）思想。定义一个类的对象作为全局变量或静态变量，它的析构函数会在程序结束时被自动调用。这是 C++ 中最常用和最优雅的方式。
* **特定于平台的机制**：例如，在 GCC/Clang 中，可以使用 **__attribute__((destructor))** **来标记一个函数，使其在程序退出时自动执行。**
* **信号处理**：可以为 **SIGTERM** **等终止信号注册处理器，但这主要用于处理外部中断的退出，而不是正常的程序流程退出。**

#### 1. 进程打开网页，和线程打开网页，有什么区别？

**这个问题可以从现代浏览器的架构来理解。**

* **进程打开网页**: 这是宏观的描述。当你启动 Chrome 浏览器时，操作系统会创建一个主进程（浏览器进程）。当你打开一个新的标签页访问网页时，现代浏览器（如 Chrome）会为你**创建一个新的独立进程**，称为**渲染进程 (Renderer Process)**。

  * **优点**: 这种多进程架构提供了很好的**稳定性和安全性**。一个标签页（渲染进程）的崩溃不会影响到其他标签页或整个浏览器。同时，不同标签页的资源是隔离的。
* **线程打开网页**: 这是微观的描述。在每一个渲染进程内部，会有**多个线程协同工作**来加载和显示网页：

  * **主线程**: 负责执行 JavaScript、解析 HTML、计算布局和绘制。
* **工作线程 (Worker Threads)**: 可以在后台执行耗时的 JavaScript 计算，避免阻塞主线程。
* **网络线程**: 负责发起和接收网络请求（如下载图片、CSS 文件）。
* **光栅线程 (Raster Threads)**: 负责将页面图层转换为位图

### 2. MySQL 几种锁

**MySQL 的锁机制是实现事务隔离性的关键。在最常用的** **InnoDB** **存储引擎中，锁的体系非常丰富：**

#### 一、 按粒度划分

* **表锁 (Table Lock)**：

  * **锁定整张表，是 MySQL 中粒度最大的锁。**
* **优点：开销小，加锁快。**
* **缺点：并发冲突的概率最高，并发性能差。**
* **MyISAM 引擎主要使用表锁。InnoDB 在执行** **ALTER TABLE** **等 DDL 语句时会自动使用表锁。**
* **行锁 (Row Lock)**：

  * **锁定某一行或多行数据，是 InnoDB 引擎的默认锁定方式，也是粒度最小的锁。**
* **优点：并发冲突概率低，并发性能好。**
* **缺点：开销大，加锁慢，可能会出现死锁。**

#### 二、 按模式划分 (行锁的两种类型)

* **共享锁 (Shared Lock, S锁)**：也称**读锁**。

  * **作用**：一个事务获取了某行的 S 锁后，可以读取该行，但不能修改。
* **兼容性**：多个事务可以同时获取同一行的 S 锁。但只要有任何一个 S 锁存在，其他事务就不能获取该行的 X 锁。
* **手动加锁**：**SELECT ... LOCK IN SHARE MODE;**
* **排他锁 (Exclusive Lock, X锁)**：也称**写锁**。

  * **作用**：一个事务获取了某行的 X 锁后，既可以读取也可以修改该行。
* **兼容性**：一旦某行被加上了 X 锁，其他任何事务都不能再为该行添加任何锁（S锁或X锁），直到持有 X 锁的事务释放锁。
* **自动加锁**：**INSERT**, **UPDATE**, **DELETE** **操作会自动为涉及的行加上 X 锁。**
* **手动加锁**：**SELECT ... FOR UPDATE;**

#### 三、 InnoDB 行锁的具体算法

**InnoDB 为了在**可重复读 (Repeatable Read) **隔离级别下解决**幻读 (Phantom Read) **问题，实现了三种行锁算法：**

* **记录锁 (Record Lock)**：

  * **这是最简单的行锁，它精确地锁定一条**索引记录**。例如** **WHERE id = 1**，如果 **id** **是主键或唯一索引，就会使用记录锁。**
* **间隙锁 (Gap Lock)**：

  * **它锁定的是一个**开区间范围**，但不包括记录本身。例如，如果一个索引有值为 10 和 20 的记录，间隙锁可以锁定** **(10, 20)** **这个范围。**
* **目的**：防止其他事务在这个间隙中 **INSERT** **新的记录，从而防止幻读。间隙锁之间是互相兼容的。**
* **临键锁 (Next-Key Lock)**：

  * **它是** **记录锁 + 间隙锁** **的组合，锁定一个**左开右闭**的区间。例如，锁定** **(10, 20]**，既锁定了值为 20 的记录，也锁定了 10 和 20 之间的间隙。
* **这是 InnoDB 在**可重复读**隔离级别下的**默认锁定算法**，它既能防止数据被修改，也能防止幻读的发生。**

#### 四、 意向锁 (Intention Lock)

 **意向锁是一种**表级锁**，但它并不与行锁冲突，而是为了协调表锁和行锁的关系。**

* **意向共享锁 (IS Lock)**：表示一个事务**打算**在表中的某些行上设置 S 锁。
* **意向排他锁 (IX Lock)**：表示一个事务**打算**在表中的某些行上设置 X 锁。
* **作用**：当一个事务想要获取一个表的表锁（如 **LOCK TABLES ... WRITE**）时，它不需要去检查表中的每一行是否有行锁，只需要检查该表上是否存在意向锁即可，这大大提高了效率。意向锁是由 InnoDB 自动管理的

### 分布式系统中，如果两个服务是两个线程，同时要对数据库中的某一行做更新操作，怎么保证更新数据是正确的

**这个问题考察的是分布式环境下的并发控制。**

* **方法一：悲观锁（利用数据库）**

  * **在事务中，使用** **SELECT ... FOR UPDATE** **来锁定要更新的行。第一个获取到锁的事务可以进行更新，第二个事务会被阻塞，直到第一个事务提交或回滚。**
  * **优点：** **简单、可靠。**
  * **缺点：** **性能较低，在高并发下可能成为瓶颈。**
* **方法二：乐观锁（利用版本号）**

  * **在数据库表中增加一个** **version** **字段。**
  * **更新流程：**

    * **读取数据和** **version**：**SELECT data, version FROM my_table WHERE id = 1;**
    * **在内存中进行计算。**
    * **提交更新，并检查** **version**：**UPDATE my_table SET data = 'new_data', version = version + 1 WHERE id = 1 AND version = old_version;**
    * **检查更新操作影响的行数。如果为 0，说明在你更新前，数据已被其他线程修改，此时需要进行重试（重新读取数据再尝试更新）。**
  * **优点：** **并发性能好。**
  * **缺点：** **实现稍复杂，冲突严重时重试成本高。**
* **方法三：分布式锁**

  * **如果更新操作不是一个简单的 SQL，而是一个复杂的业务流程（包含多次读写），那么需要使用分布式锁。**
  * **可以基于** **Redis (**SETNX **命令)** **或** **ZooKeeper** **来实现。**
  * **只有一个服务能获取到锁，获取锁的服务执行业务逻辑，执行完毕后释放锁。其他服务在获取锁失败后，可以选择等待或直接失败。**
  * **优点：** **适用范围广，能保证复杂操作的原子性。**
  * **缺点：** **引入了外部依赖（Redis/ZK），增加了系统复杂度，且需要考虑锁的超时、续期等问题。**

# 逆序输出百万行大文本文件的方法

逆序输出一个大文本文件（如100万行）需要考虑内存效率和性能问题。以下是几种可行的方法：

## 1. 使用tac命令（Linux/Unix系统）

最简单高效的方法是使用系统自带的 `tac`命令（cat的反写）：

`tac`会从最后一行开始反向输出文件内容，内存效率很高，适合大文件。

## 2. 使用Python处理

## 3. 使用AWK

## 4. 使用Perl

## 注意事项

1. **内存考虑** ：对于极大文件，方法2-4可能会消耗较多内存，因为它们会将所有行存储在内存中
2. **性能** ：`tac`命令通常是最高效的选择
3. **编码问题** ：处理非ASCII文本时要注意编码问题
4. **临时文件** ：对于极大文件，可能需要考虑使用临时文件分段处理

对于100万行的文本文件，`tac`命令通常是最佳选择，除非你有特殊需求需要在特定编程环境中实现。
