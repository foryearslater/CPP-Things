# 小红书面经

## 1.信号和槽的机制以及底层原理

**信号与槽是一种用于对象间通信的机制。它的核心思想是，当一个对象的状态发生改变时（例如，用户点击了一个按钮），它可以“发射”一个**信号。其他对此变化感兴趣的对象可以将其一个函数（称为**槽**）“连接”到这个信号上。当信号被发射时，所有与之连接的槽函数都会被自动调用。

| **观察者模式** | **构成了信号与槽的**基本骨架，实现了对象间的**松耦合**和事件通知机制。                   |  |  |
| -------------------- | ---------------------------------------------------------------------------------------------------- | - | - |
| **命令模式**   | **将**槽函数的调用封装成对象，用于处理**跨线程和异步**调用，是实现其强大功能的核心。     |  |  |
| **中介者模式** | **由**元对象系统**扮演中介角色，管理所有连接关系，避免了发送者和接收者之间的直接引用。** |  |  |

## 2.select poll epoll 区别

IO多路复用 ：一个线程同时管理和检测多个io是否就绪

都是同步IO：

int n = read(fd, buf, sz);

| **特性**               | **select**                                                                  | **poll**                                                                     | **epoll**                                                                                                           |
| ---------------------------- | --------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| **API 使用**           | **简单但繁琐。需要3个**fd_set**，并且每次调用后都会被内核修改，必须重置。** | **较简单。使用**pollfd**结构体数组，无需每次重置。**                   | **较复杂。由三个函数组成：**epoll_create**,** **epoll_ctl**, **epoll_wait**。                     |
| **文件描述符(FD)限制** | **有**。受限于**FD_SETSIZE**宏，通常是**1024**。                | **无**。理论上只受限于系统内存和进程最大文件句柄数。                         | **无**。和 **poll** **一样，理论上无限制。**                                                            |
| **内存拷贝**           | **每次调用**都需要将完整的**fd_set**从用户空间拷贝到内核空间。        | **每次调用**都需要将完整的**pollfd**数组从用户空间拷贝到内核空间。     | **仅在**epoll_ctl**时**需要拷贝。**epoll_wait**几乎不涉及FD集合的拷贝，内核和用户空间共享同一份FD集合。 |
| **内核扫描方式**       | **线性扫描**。内核需要遍历所有传入的FD，检查它们的状态。                    | **线性扫描**。和 **select** **类似，内核仍需遍历所有传入的FD。** | **事件驱动/回调**。内核通过回调机制，只返回处于就绪状态的FD，无需遍历全部FD。                                       |
| **性能复杂度**         | **O(N)**。性能随监控的FD数量N线性下降。                                     | **O(N)**。性能同样随监控的FD数量N线性下降。                                  | **O(K)**。性能只与活跃的FD数量K有关，与总数N无关。这是质的飞跃。                                                    |
| **触发模式**           | **水平触发 (Level Triggered, LT)**。                                        | **水平触发 (Level Triggered, LT)**。                                         | **同时支持水平触发(LT)和边缘触发(ET)**。                                                                            |
| **可移植性**           | **非常好**。几乎所有主流操作系统都支持，符合POSIX标准。                     | **较好**。大部分类Unix系统支持。                                             | **差**。是**Linux特有**的实现，其他系统没有（但有类似机制如kqueue）。                                         |

### **区别：**

#### **接口上**

* select、poll 只有一个接口
* epoll 有三个接口；事实上 epoll 用两个接口实现上述一个接口的功能

#### **传参以及返回上**

* select 需要传递可读、可写、异常三个集合，select 返回后仍需遍历取出就绪事件
* poll 只需要传递一个集合，poll 返回后仍需遍历取出就绪事件
* epoll 通过 epoll_ctl 只需添加一次，epoll_wait 取出就绪的事件

#### **底层实现上**

* select、poll 通过轮询；select 是数组，poll 是链表
* epoll 通过回调机制，将就绪 io 从黑/红树拷贝到就绪队列

#### **管理 fd 数量上**

* select 有限制 FD_SETSIZE
* poll 和 epoll 没有限制

#### **触发机制上**

* select、poll 只有水平触发
* epoll 有水平触发和边缘触发

#### 效率

少量fd，比较活跃，poll, select

大量fd，比较活跃，epoll

#### 水平触发 (LT) vs. 边缘触发 (ET)

**这是** **epoll** **的一大特色，**select **和** **poll** **只有水平触发。**

* **水平触发 (Level Triggered, LT) - 只要有水，就一直报警**

  * **含义**：只要文件描述符处于可读/可写状态，**epoll_wait** **每次被调用都会返回这个FD。**
  * **优点**：编程更简单，不容易出错。如果这次没处理完数据，下次调用 **epoll_wait** **还会提醒你。**
  * **缺点**：可能会导致不必要的重复唤醒。
* **边缘触发 (Edge Triggered, ET) - 水位变化时，才报警一次**

  * **含义**：只有当文件描述符的状态发生**变化**时（例如，从不可读变为可读），**epoll_wait** **才会返回这个FD，而且通常只返回**一次**。**
  * **优点**：效率极高，避免了LT模式下的重复唤醒。Nginx、Redis等高性能中间件都采用ET模式。
  * **缺点**：编程更复杂。你必须在收到通知后，一次性地将缓冲区的数据全部读/写完（通常使用非阻塞IO循环读写直到返回**EAGAIN**错误），否则剩下的数据可能再也得不到处理通知了，导致数据丢失或程序饿死。

### **水平触发**

* **定义** ：只要满足 io 就绪条件就会触发
* **特点** ：
* 没有处理，下一次 epoll_wait 依然可以拿到就绪事件
* 没有处理完全，下一次 epoll_wait 依然可以拿到就绪事件

### **边缘触发**

* **定义** ：新的 io 就绪事件到来就触发一次
* **特点** ：
* 没有处理，下一次 epoll_wait 拿不到就绪事件
* 没有处理完全，下一次 epoll_wait 拿不到就绪事件

### **总结**

* 边缘触发效率高
* 最好的情况：可读事件采用水平触发，可写事件采用边缘触发，但是 linux 不支持这样做

#### 总结与选择

| **场景**                                                            | **推荐使用的技术** | **理由**                                                                                                                                                                                        |
| ------------------------------------------------------------------------- | ------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **高并发、海量连接的Linux服务器** **(如Web服务器, IM服务器)** | **epoll**          | **性能最高，能够轻松应对C10K甚至C100K问题。是现代Linux高性能网络编程的**不二之选**。**                                                                                                          |
| **连接数不多，但要求跨平台**                                        | **select**         | **拥有最好的可移植性，在Windows等系统上也能工作。对于并发几百个连接的场景，其性能也足够用。**                                                                                                   |
| **select** **的简单替代品** **(解决了1024限制)**        | **poll**           | **如果你只是觉得**select**的1024限制和**fd_set**操作繁琐，但又不需要**epoll**的极致性能和复杂性，**poll**是个不错的选择。但在Linux上，几乎没有理由不直接用**epoll**。** |

* **epoll_create** **: 在内核中创建一个专门用于发布“I/O事件”的**公告板**。**
* **epoll_ctl**: 作为一个管理员，负责在这个公告板上**添加、修改或删除**你关心的“监控项”（比如某个网络连接是否可读）。
* **epoll_wait**: 你（作为程序）搬个小板凳坐在公告板前**等待**。一旦有你关心的事件发生（比如某个连接收到了数据），公告板上就会出现通知，**epoll_wait** **就会立刻返回，告诉你哪些事件发生了。**

### 1. **epoll_create** **- 创建公告板**

**code**C

```
int epoll_create(int size);
int epoll_create1(int flags);
```

* **作用**: 在内核中创建一个 **epoll** **实例，并返回一个指向该实例的文件描述符。 这个** **epoll** **实例可以看作是一个事件注册中心或我们比喻中的“公告板”。后续的所有操作都将通过这个返回的** **epoll_fd** **来进行。**
* **参数**:

  **size** **(在** **epoll_create** **中): 在早期的内核版本中，这个参数用来告诉内核你预计要监控的文件描述符数量，以便内核分配合适大小的内部数据结构。**
* **flags** **(在** **epoll_create1** **中):** **epoll_create1** **是更现代、更推荐的函数。**flags **参数可以设置为** **EPOLL_CLOEXEC**，表示当程序执行 **exec** **系列函数时，这个** **epoll** **文件描述符会自动关闭，这在多线程或多进程程序中能避免一些资源泄露问题。如果不需要此特性，可以设为 0。**
* **返回值**:

  **成功：返回一个非负整数，即** **epoll** **实例的文件描述符。**
* **失败：返回 -1，并设置** **errno**。

 **一句话总结**: **epoll_create** **就是初始化** **epoll** **机制，获取一个操作句柄（**epoll_fd**）。**

### 2. **epoll_ctl** **- 管理监控项**

**code**C

```
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```

* **作用**: 控制（添加、修改、删除）**epoll** **实例所监控的文件描述符及其关联的事件。 这就像在公告板上贴上或撕下你要关注的便签。**
* **参数**:

  **epfd**: **epoll_create** **返回的那个** **epoll** **文件描述符。告诉** **epoll_ctl** **要操作的是哪个“公告板”。**
* **op**: 操作类型，主要有三种：

  **EPOLL_CTL_ADD**: **添加**一个新的文件描述符 **fd** **到** **epfd** **中进行监控。**

  **EPOLL_CTL_MOD**: **修改**一个已存在的文件描述符 **fd** **的监控事件。**

  **EPOLL_CTL_DEL**: **删除**一个文件描述符 **fd**，不再对其进行监控。
* **fd**: 需要被监控的那个文件描述符（例如，一个 **socket** **连接的 fd）。**
* **event**: 一个指向 **epoll_event** **结构体的指针。这个结构体告诉** **epoll** **你对这个** **fd** **关心什么事件**。

  **epoll_event** **结构体通常包含两个重要成员：**

  **code**C

```
  struct epoll_event {
      uint32_t     events;      /* 关心的事件，如 EPOLLIN, EPOLLOUT */
      epoll_data_t data;        /* 用户数据，通常用来存放 fd 自身 */
  };
```

* **events**: 你想监听的事件类型，是位掩码的组合。常用值有：

  * **EPOLLIN**: 关联的文件可读（比如 socket 收到了数据）。
  * **EPOLLOUT**: 关联的文件可写（比如 socket 的发送缓冲区未满）。
  * **EPOLLET**: 设置为边缘触发（Edge Triggered）模式。这是 **epoll** **高效的关键之一。**
* **data**: 一个联合体，可以用来存放用户数据。最常见的用法是 **event.data.fd = fd;**，这样当 **epoll_wait** **返回时，你可以直接从返回的事件中知道是哪个** **fd** **触发了事件。**
* **返回值**:

  * **成功：返回 0。**
* **失败：返回 -1，并设置** **errno**。

 **一句话总结**: **epoll_ctl** **负责具体管理你要监听哪些连接，以及监听它们的什么状态。**

---

### 3. **epoll_wait** **- 等待事件发生**

**code**C

```
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```

* **作用**: 这是 **epoll** **的核心循环函数。它会**阻塞**当前进程（或线程），直到** **epoll** **实例 (**epfd**) 上有事件发生，或者等待超时。 这就是坐在公告板前等待的过程。一旦有事件，它会把就绪的事件从内核拷贝到用户空间。**
* **参数**:

  * **epfd**: **epoll_create** **返回的那个** **epoll** **文件描述符。**
* **events**: 一个 **epoll_event** **结构体数组的指针。内核会将已就绪的事件填充到这个数组中。 这是** **epoll** **高效的另一个关键：它只返回**活跃**的连接，你不需要像** **select** **那样自己去遍历所有连接。**
* **maxevents**: 告诉内核 **events** **数组有多大，即本次调用最多能接收多少个就绪事件。**
* **timeout**: 超时时间（毫秒）。

  **-1**: 永久阻塞，直到有事件发生。

  **0**: 立即返回，即使没有任何事件发生（非阻塞检查）。

  **> 0**: 最多等待 **timeout** **毫秒，如果期间有事件则返回，否则超时后返回。**
* **返回值**:

  * **成功：返回**就绪的文件描述符数量**（一个大于 0 的整数）。**
* **0**: 超时，没有任何事件发生。
* **失败：返回 -1，并设置** **errno**。

 **一句话总结**: **epoll_wait** **是程序的主循环，它负责高效地等待并获取所有已经准备好 I/O 的连接。**

### 三个函数如何协同工作

* **初始化**:

  * **调用** **epoll_create()** **创建一个** **epoll** **实例 (**epoll_fd**)。**
* **创建一个监听** **socket** **(**listen_fd**)，并** **bind()** **和** **listen()**。
* **调用** **epoll_ctl()** **将** **listen_fd** **添加到** **epoll_fd** **中，监听** **EPOLLIN** **事件（等待新连接）。**
* **主事件循环**:

  * **在一个** **while(1)** **循环中，调用** **epoll_wait()** **等待事件。**
* **epoll_wait()** **返回，告诉你有一个或多个事件发生了。**
* **遍历返回的** **events** **数组。**
* **如果是** **listen_fd** **触发了事件**: 说明有新的客户端连接请求。调用 **accept()** **接受新连接，得到一个新的** **conn_fd**。然后调用 **epoll_ctl()** **将这个** **conn_fd** **添加**到 **epoll_fd** **中，监听** **EPOLLIN** **事件（等待客户端发来数据）。**
* **如果是某个** **conn_fd** **触发了事件**: 说明这个客户端连接有数据可读。调用 **read()** **或** **recv()** **从这个** **conn_fd** **读取数据，然后进行业务处理。**
* **如果连接关闭**: **read()** **通常会返回 0，这时需要调用** **epoll_ctl()** **将这个** **conn_fd** **从** **epoll_fd** **中**删除**，并** **close()** **这个** **conn_fd**。

## 3.对流媒体播放器了解

* **解协议** **：根据HLS、DASH等协议，解析清单文件，发起HTTP请求获取媒体切片。**
* **解封装**：将下载好的MP4或TS切片分离出编码后的视频流和音频流。
* **解码**：调用设备的硬解码器或软解码器，将压缩的数据还原成可供显示的原始图像帧（YUV/RGB）和音频样本（PCM）。
* **音视频同步**：根据时间戳，确保声音和画面对齐。
* **渲染**：将图像送到显卡，声音送到声卡，最终呈现给你

## 4.给你mp4格式的视频怎么渲染上屏中间的步骤

| **步骤**          | **输入**                    | **处理模块**                | **输出**                      | **核心任务**                   |
| ----------------------- | --------------------------------- | --------------------------------- | ----------------------------------- | ------------------------------------ |
| **1. 解封装**     | **MP4 文件**                | **Demuxer**                 | **压缩的音视频包**            | **分离音视频数据流**           |
| **2. 解码**       | **压缩的音视频包**          | **Decoder**                 | **原始的音视频帧 (YUV, PCM)** | **将压缩数据还原成原始数据**   |
| **3. 音视频同步** | **原始的音视频帧**          | **Sync Clock**              | **同步后的帧**                | **保证音画对齐**               |
| **4. 视频处理**   | **YUV 视频帧**              | **Color Converter**         | **RGB 视频帧**                | **转换为屏幕可显示的颜色格式** |
| **5. 渲染/播放**  | **RGB 视频帧 / PCM 音频帧** | **Renderer / Audio Player** | **屏幕画面 / 扬声器声音**     | **最终呈现给用户**             |

## 5.c++五个分区

## 6.静态变量介绍

## 7.输出

int a[5] = {1, 2, 3, 4, 5};
int *ptr = (int *)(&a + 1);
printf("%d,%d", *(a + 1), *(ptr - 1));

输出 2 ，5

## 8.算法 和为k的路径输出






**在看步骤之前，必须清楚几个基本概念：**

* **容器 (Container)**：也叫格式，就是文件的“壳”，如 **.mp4**, **.mkv**, **.mov**, **.flv**。它本身不决定画质和音质，只是一个“打包”音视频流和其他数据（如字幕、元数据）的规范。
* **流 (Stream)**：容器里装的东西。一个视频文件通常至少包含一个视频流和一个音频流。
* **编解码器 (Codec)**：**Co**der/**Dec**oder 的缩写。这是压缩和解压数据的算法。

  * **视频编解码器**：如 H.264 (AVC), H.265 (HEVC), VP9, AV1。它们负责压缩原始的视频帧图像，大幅减小体积。
* **音频编解码器**：如 AAC, MP3, Opus。它们负责压缩原始的音频波形数据（PCM）。
* **数据包 (Packet)**：经过编码器压缩后，包含一小段音视频数据的基本单元（也叫“编码后数据”）。
* **帧 (Frame)**：

  * **视频帧**：解码后得到的一张张静态图像。
* **音频帧**：解码后得到的一小段连续的音频采样数据 (PCM)。

---

### 一、音视频编码 (Encoding) 的步骤

 **这里的“编码”通常指**转码 (Transcoding)**，即将一个已有的媒体文件转换为另一个格式/编码。这是最常见的用例。**

   **目标**：将 **input.mov** **转换为一个经过优化的** **output.mp4** **文件。**
命令示例**：**ffmpeg -i input.mov -c:v libx264 -crf 23 -c:a aac -b:a 192k output.mp4

  **FFmpeg 内部的流水线步骤如下：**

#### 1. 输入 (Input) & 解复用 (Demuxing)

* **FFmpeg 读取** **input.mov** **文件。**
* **它会调用** **MOV 解复用器 (Demuxer)**。
* **Demuxer 负责解析 MOV 容器格式，识别出里面的流。比如，它发现里面有一个 H.264 编码的视频流和一个 PCM 编码的音频流。**
* **它将这些流分离成独立的、依然处于**编码状态**的数据包 (Packets)。**

 **数据流向**：
[input.mov 文件] -> [MOV Demuxer] -> [视频 Packet 流 (H.264)] + [音频 Packet 流 (PCM)]

#### 2. 解码 (Decoding)

* **因为我们的目标是要对内容进行**重新编码**（可能会改变分辨率、码率等），所以必须先把输入的压缩数据变回原始数据。**
* **FFmpeg 将上一步得到的视频数据包送入** **H.264 解码器 (Decoder)**。
* **H.264 解码器将这些数据包解码成一系列原始的、未压缩的**视频帧 (Video Frames)**（例如 YUV 格式的图像数据）。**
* **同样，音频数据包被送入对应的解码器（在这个例子里，PCM 是原始数据，无需“解码”），得到原始的**音频帧 (Audio Frames)**（PCM 采样数据）。**

 **数据流向**：
[视频 Packet 流] -> [H.264 Decoder] -> [原始视频帧流]
[音频 Packet 流] -> [PCM Decoder] -> [原始音频帧流]

#### 3. 滤镜处理 (Filtering) - 可选但常用

* **在重新编码之前，我们可以对原始帧进行各种处理。例如缩放、裁剪、加水印、调色、改变音量等。**
* **如果命令中有** **-vf scale=1280:720** **这样的参数，那么解码后的原始视频帧会流经缩放滤镜，输出改变了分辨率的新原始视频帧。**

 **数据流向**：
[原始视频帧流] -> [Filtergraph, e.g., scale] -> [处理后的原始视频帧流]

#### 4. 编码 (Encoding)

* **这是核心的压缩步骤。**
* **经过处理的原始视频帧被送入用户指定的**视频编码器 (Encoder)**，即** **-c:v libx264**。
* **libx264** **编码器根据** **-crf 23** **(质量参数) 等设置，将这些原始视频帧压缩成新的**视频数据包 (H.264 Packets)**。**
* **同样，原始音频帧被送入** **-c:a aac** **指定的** **AAC 编码器**，根据 **-b:a 192k** **(码率) 等设置，压缩成新的**音频数据包 (AAC Packets)**。**

 **数据流向**：
[处理后的原始视频帧流] -> [libx264 Encoder] -> [新的视频 Packet 流 (H.264)]
[原始音频帧流] -> [AAC Encoder] -> [新的音频 Packet 流 (AAC)]

#### 5. 复用 (Muxing) & 输出 (Output)

* **FFmpeg 调用** **MP4 复用器 (Muxer)**。
* **Muxer 的工作与 Demuxer 相反。它接收新编码好的视频和音频数据包流。**
* **它按照 MP4 容器的规范，将这些数据包交织在一起，并写入必要的元数据（如时长、编码信息、时间戳等）。**
* **最终生成** **output.mp4** **文件。**

 **数据流向**：
[新视频 Packet 流] + [新音频 Packet 流] -> [MP4 Muxer] -> [output.mp4 文件]

---

### 二、音视频解码 (Decoding) 的步骤

**解码过程相对简单，本质上是编码过程的前半部分。**

  **目标**：播放 **video.mp4** **文件，或将其内容提取为原始数据。**
命令示例**：**ffplay video.mp4 **(ffplay 是使用 FFmpeg 库的播放器) 或** **ffmpeg -i video.mp4 -f rawvideo output.yuv** **(解码为原始视频)**

  **FFmpeg 内部的流水线步骤如下：**

#### 1. 输入 (Input) & 解复用 (Demuxing)

* **与编码的第一步完全相同。**
* **FFmpeg 读取** **video.mp4** **文件。**
* **调用** **MP4 Demuxer** **解析容器，分离出里面的视频流（如 H.264）和音频流（如 AAC）。**
* **输出独立的、编码状态的**数据包 (Packets)**。**

 **数据流向**：
[video.mp4 文件] -> [MP4 Demuxer] -> [视频 Packet 流 (H.264)] + [音频 Packet 流 (AAC)]

#### 2. 解码 (Decoding)

* **FFmpeg 自动检测流的编码类型。**
* **它将 H.264 视频数据包送入** **H.264 解码器**，输出**原始视频帧**。
* **它将 AAC 音频数据包送入** **AAC 解码器**，输出**原始音频帧**。

 **数据流向**：
[视频 Packet 流] -> [H.264 Decoder] -> [原始视频帧流]
[音频 Packet 流] -> [AAC Decoder] -> [原始音频帧流]

#### 3. 输出 (Output)

* **解码后的原始数据有了最终去向：**

  * **对于播放器 (ffplay)**：原始视频帧被送到显卡进行渲染显示，原始音频帧被送到声卡进行播放。
  * **对于解码命令**：原始视频帧被写入 **output.yuv** **文件，原始音频帧可以被写入** **output.pcm** **文件。**
  * **对于后续处理**：这些原始帧可以进入滤镜链进行分析或处理。

 **数据流向**：
[原始视频帧] -> [显卡/文件/滤镜]
[原始音频帧] -> [声卡/文件/滤镜]

### 总结

| **阶段**        | **编码 (转码) 过程**                                  | **解码过程**                                          |
| --------------------- | ----------------------------------------------------------- | ----------------------------------------------------------- |
| **1. 输入**     | **解复用 (Demuxing)**: 打开容器，分离出压缩的数据包。 | **解复用 (Demuxing)**: 打开容器，分离出压缩的数据包。 |
| **2. 处理核心** | **解码 (Decoding)**: 将输入的压缩包解码成原始帧。     | **解码 (Decoding)**: 将输入的压缩包解码成原始帧。     |
| **3. ...**      | **滤镜 (Filtering)**: (可选) 对原始帧进行处理。       |                                                             |
| **4. ...**      | **编码 (Encoding)**: 将原始帧重新压缩成新的数据包。   |                                                             |
| **5. 输出**     | **复用 (Muxing)**: 将新的数据包打包成最终的容器文件。 | **输出**: 将原始帧送给显示/播放设备或写入文件。       |
