# 一面：

1.cmake、makefile底层原理

* Makefile：定义编译规则，make工具根据依赖关系自动编译。底层通过文件时间戳判断是否需要重新编译。
* CMake：跨平台构建工具，生成Makefile或其他项目文件（如VS工程），通过CMakeLists.txt描述项目结构和依赖。

2.qt底层渲染用的什么,opengl和opencv区别

* Qt底层渲染主要用OpenGL（Qt Quick/Widgets可选OpenGL加速），也支持软件渲染。
* OpenGL是图形渲染API，负责绘制图形；OpenCV是计算机视觉库，处理图像分析和算法。

3.stl容器

* 常见：vector、list、deque、map、set、unordered_map、unordered_set、stack、queue等。

4.map和unordered_map 优缺点

* map：红黑树实现，有序，查找O(logN)，插入/删除慢。
* unordered_map：哈希表实现，无序，查找O(1)均摊，插入/删除快，但遍历无序。

5.vector与数组区别

* **vector** ：动态数组，支持自动扩容（通过 `reserve` 或插入时重新分配内存），提供迭代器、STL 算法兼容、边界检查（`at` 方法）。底层使用连续内存块。
* **数组** ：静态或动态分配的固定大小内存块，无自动扩容，无迭代器支持，功能简单。C++ 原生数组（如 `int arr[10]`）或 `new` 分配的数组需要手动管理生命周期。

6.c++怎么避免内存泄漏

* 使用 RAII：资源在对象构造时获取，析构时释放。
* 智能指针：`std::unique_ptr`（独占所有权）、`std::shared_ptr`（共享所有权，引用计数）、`std::weak_ptr`（避免循环引用）。
* 避免裸指针：优先使用容器和智能指针；手动管理时，确保 `delete` 或 `delete[]` 与 `new` 配对。
* 工具辅助：使用 Valgrind 或 AddressSanitizer 检测泄漏。

7.c++虚函数使用机制

虚函数通过虚函数表（vtable）实现运行时多态。每个包含虚函数的类有一个 vtable（指向函数指针数组）。对象实例有虚指针（vptr），指向 vtable。调用虚函数时，通过 vptr 查找 vtable 中的函数地址，实现动态绑定。基类虚函数允许派生类重

8.构造函数不能为虚函数，析构函数不能为虚函数

* **构造函数不能为虚函数** ：对象构造时，vptr 未初始化，无法实现多态。构造函数按继承层次从基类到派生类调用。
* **析构函数可以为虚函数** ：确保通过基类指针删除派生类对象时，调用正确的析构函数链（先派生后基类）。如果不虚，基类指针只会调用基类析构，造成资源泄漏。

9.linux查询一些gpu内存这些信息的命令

* NVIDIA GPU：`nvidia-smi`（显示 GPU 利用率、内存使用等）。
* AMD GPU：`radeontop` 或 `rocm-smi`。
* 通用：`lspci | grep VGA`（列出 GPU 硬件）；`glxinfo | grep memory`（OpenGL 内存信息）；`cat /sys/class/drm/card0/device/mem_info`（某些驱动）

手撕 ：string构造，析构，移动构造，拷贝构造，移动赋值，拷贝赋值

# 二面：

1.项目经历拷打

2.写题 翻转字符串

3.手写memcpy restrict作用


void* my_memcpy(void* dest, constvoid* src, size_t n) {

    char* d = static_cast<char*>(dest);

    constchar* s = static_cast<constchar*>(src);

    for (size_t i = 0; i < n; ++i) {

    d[i] = s[i];

    }

    return dest;

}

**restrict作用** ：`restrict` 关键字告诉编译器指针指向的内存区域不与其他指针重叠，允许优化（如向量化），提高性能。用于 memcpy 等函数避免不必要的检查

4.vector与list区别 连续空间比上那些不连续空间有什么优势


* **区别** ：`vector` 使用连续内存，支持 O(1) 随机访问；`list` 使用双向链表，支持 O(1) 插入/删除，但随机访问 O(N)。
* **连续空间优势** ：CPU cache 友好（空间局部性），遍历快；支持 STL 算法（如 `std::sort`）；内存分配简单，减少碎片

5.cpu进行取一次地址需要做什么

CPU 取地址（load 操作）：

* 计算有效地址（基址 + 偏移）。
* 检查 cache（L1/L2/L3），若命中，直接加载到寄存器。
* 若缺失，从主存加载（可能通过总线），更新 cache。
* 处理虚拟地址到物理地址转换（MMU、TLB）。
* 可能触发页面错误（page fault）。

6.假如有一个string转化c接口char*的要怎么操作

## Vector频繁push_back的影响及优化方案

### 频繁push_back的主要影响

1. **内存重新分配问题** ：当vector容量不足时，每次push_back可能导致内存重新分配，这个过程需要复制所有现有元素到新内存区域，效率较低
2. **性能波动** ：内存重新分配不是线性增长，而是按一定比例(通常是翻倍)扩展，导致性能表现不稳定
3. **引用失效风险** ：重新分配会使之前获取的元素指针、引用和迭代器失效，可能引发程序错误

### 优化解决方案

### 预先规划容量

* 如果能够预估元素的大致数量，提前预留足够空间可以避免多次重新分配
* 这种方法特别适用于元素数量可预测或需要处理大量数据的场景

### 选择更高效的插入方式

* 对于构造代价高的对象，使用emplace系列方法可以直接在容器内构造对象，避免临时对象的创建和拷贝
* 批量插入数据时，使用范围插入方法比多次单元素插入更高效

### 考虑替代容器

* 如果主要在两端插入，双端队列可能是更好的选择
* 如果插入位置固定且频繁，链表类容器可能更适

### **

C++ 八股文（底层向）**

#### **1. 自旋锁 vs 互斥锁**

* **自旋锁（Spinlock）**
  * **原理** ：线程在获取锁失败时，不会阻塞，而是循环（自旋）检查锁是否可用（`while (!lock.try_acquire())`）。
  * **适用场景** ：锁竞争时间短，避免线程切换开销（如内核态、高并发短任务）。
  * **缺点** ：长时间自旋会浪费CPU。
* **互斥锁（Mutex）**
  * **原理** ：获取锁失败时，线程进入阻塞状态，让出CPU（通过系统调用如 `futex`）。
  * **适用场景** ：锁竞争时间长，减少CPU空转。
  * **缺点** ：线程切换有开销。

#### **2. `atomic` 的底层实现机理**

* **底层机制** ：
* **编译器屏障** ：禁止指令重排（如 `volatile` + 内存屏障指令）。
* **CPU原子指令** ：如 `x86` 的 `LOCK` 前缀指令（`LOCK CMPXCHG`）、`ARM` 的 `LDREX/STREX`。
* **缓存一致性协议** ：如 `MESI`，确保多核间数据同步。

#### **3. `shared_ptr` 的引用计数如何保证线程安全？**

* **线程安全级别** ：
* **引用计数本身** ：通过 `atomic` 操作（如 `fetch_add`）保证原子性。
* **指向的对象** ：`shared_ptr` 不保证对象操作的线程安全，需额外加锁。
* **实现细节** ：
* 引用计数通常用 `std::atomic<int>` 或平台特定的无锁原子操作（如 `__gnu_cxx::__atomic_add`）。

#### **4. 右值/纯右值/将亡值，`move` 对 `const` 容器的影响**

* **右值分类** ：
* **纯右值（prvalue）** ：如临时对象、字面量。
* **将亡值（xvalue）** ：如 `std::move` 后的对象，可被“窃取”资源。
* **`move` 一个 `const` 容器** ：
* **语法允许** ：`std::move(const vec)` 返回 `const` 右值引用。
* **实际效果** ：由于 `const` 限制，无法调用移动构造函数（因移动操作需修改源对象），退化为拷贝。

#### **5. 完美转发（`forward`）的功能与使用场景**

* **功能** ：保持参数的值类别（左值/右值），避免不必要的拷贝。
* **使用场景** ：模板函数中转发参数到其他函数，如：

<pre data-sourcepos="38:1-43:4"><div data-sentry-component="CustomCode" data-sentry-source-file="index.tsx"><div class="MarkDown_block_header__Jpkhb"><div class="MarkDown_language__DItCk">Cpp</div><div><div class="MarkDown_copyBtn__6Wmrp" data-sentry-component="CopyBtn" data-sentry-source-file="index.tsx"><div class="style_container__s7Iv8" aria-describedby=":r99:"><div class="style_copyIcon__w3b6v"></div></div></div></div></div><div class="MarkDown_scroller_wrapper__sPX_f"><div class="MarkDown_code_block_scroller__mJfhR md_code_block_scroller"><div turnid="379f46ac-1f20-42f3-a1e4-5b564658529d" sentenceid="800c8bd8-09db-484f-90e7-37abc46b3388" extrainfo="[object Object]" data-sourcepos="38:1-43:4" sourceposition="[object Object]"><code class="language-cpp"><span></span>template<typename T>
voidwrapper(T&& arg)<span>{
</span><span></span><span>target</span><span>(std::forward<T>(arg));  </span><span>// 保持 arg 的原始值类别</span><span>
</span>  }</code></div></div></div></div></pre>

* **原理** ：根据模板参数 `T` 的类型推导，`forward` 返回左值或右值引用。

#### **6. 能否传 `const &&` 参数？会发生什么？**

* **语法允许** ：可以定义 `void func(const int&&)`，但 **几乎无用** 。
* **行为** ：
* `const &&` 只能绑定到右值，但右值本就可被移动，加 `const` 后禁止移动语义，退化为拷贝。
* **典型错误** ：`std::move` 一个 `const` 对象后传递给 `const&&`，无法触发移动构造。

#### **7. `unordered_map` 如何将大数映射到 bucket 数量？**

* **步骤** ：

1. **哈希函数** ：将 key 转换为 `size_t`（如 `std::hash<K>`）。
2. **取模运算** ：`hash_value % bucket_count`，但实际用 **位运算优化** （当 `bucket_count` 是 2^n 时，`hash & (bucket_count - 1)`）。
3. **处理冲突** ：链地址法（链表）或开放寻址法。

#### **8. `vector::erase` 的具体实现**

* **流程** ：

1. **移动元素** ：将删除点后的元素向前移动（`std::move` 或拷贝）。
2. **更新大小** ：`size--`，析构尾部多余元素（如 `pop_back`）。
3. **迭代器失效** ：被删除元素及其后的迭代器均失效。

* **时间复杂度** ：`O(n)`（需移动后续所有元素）。

### **总结**

* **锁** ：自旋锁（CPU忙等） vs 互斥锁（线程阻塞）。
* **原子操作** ：依赖 CPU 指令（如 `LOCK`）和缓存一致性。
* **智能指针** ：`shared_ptr` 计数原子化，对象操作需额外同步。
* **右值语义** ：`move` 对 `const` 无效，`forward` 用于完美转发。
* **哈希表** ：哈希值取模映射到 bucket，`erase` 需移动元素。

#### **1. 智能指针**

* **核心分类** ：
* `unique_ptr<T>`：独占所有权，不可拷贝但可移动。
* `shared_ptr<T>`：共享所有权，引用计数为0时释放资源，线程安全（计数原子操作）。
* `weak_ptr<T>`：解决循环引用问题，不增加引用计数，需 lock() 转为 `shared_ptr` 使用。
* **底层实现** ：
* `shared_ptr` 通常包含**对象指针**和 **控制块指针** （引用计数、弱引用计数、删除器）。
* `unique_ptr` 无额外开销，本质是 RAII 包装的原始指针。

#### **2. C++11 新特性**

* **移动语义** ：`std::move`（将左值转为右值）、移动构造/赋值（避免深拷贝）。
* **智能指针** ：`unique_ptr`/`shared_ptr`/`weak_ptr`。
* **lambda 表达式** ：捕获上下文变量的匿名函数，常用于回调（如 STL 算法、线程函数）。
* **`auto` 类型推导** ：编译器自动推导变量类型（如 `auto it = vec.begin()`）。
* **范围 for 循环** ：`for (auto& x : container)` 遍历容器。
* **右值引用** ：`T&&`，支持移动语义和完美转发。

#### **3. 锁和条件变量的内部机制**

* **互斥锁（Mutex）底层** ：
* 依赖操作系统内核实现（如 Linux 的 `pthread_mutex_t`）。
* 竞争时通过 **系统调用** （如 `futex`）阻塞线程，释放时唤醒等待队列中的线程。
* 自旋锁（`std::spinlock`）是用户态锁，通过循环原子检查锁状态，避免内核切换开销（适合短临界区）。
* **条件变量（Condition Variable）** ：
* 配合互斥锁使用，实现线程间的 **事件通知** 。
* 核心操作：`wait(lock)`（释放锁并阻塞）、`notify_one()`/`notify_all()`（唤醒等待线程）。
* 底层依赖内核的等待队列（如 Linux 的 `pthread_cond_t`）。

#### **4. 实现线程同步的方式**

* **互斥锁 + 条件变量** ：解决生产者-消费者问题（如自动驾驶中传感器数据读写同步）。
* **读写锁（`std::shared_mutex`）** ：读共享、写独占，适合读多写少场景（如地图数据读取）。
* **信号量（`std::counting_semaphore`）** ：控制并发资源数（如限制线程池最大线程数）。
* **原子操作（`std::atomic`）** ：无锁同步，适合简单计数（如任务完成标志）。

#### **5. 设计模式（单例模式重点）**

* **常用设计模式** ：
* 创建型：单例、工厂、建造者；
* 结构型：适配器、装饰器、代理；
* 行为型：观察者、策略、状态。
* **单例模式** ：
* **定义** ：保证一个类仅一个实例，全局访问点。
* **实现要点** ：
  * 私有化构造函数，禁止拷贝/赋值（`= delete`）；
  * **懒汉模式** （C++11 线程安全版）：

<pre data-sourcepos="53:1-65:6"><div data-sentry-component="CustomCode" data-sentry-source-file="index.tsx"><div class="MarkDown_block_header__Jpkhb"><div class="MarkDown_language__DItCk">Cpp</div><div><div class="MarkDown_copyBtn__6Wmrp" data-sentry-component="CopyBtn" data-sentry-source-file="index.tsx"><div class="style_container__s7Iv8" aria-describedby=":rao:"><div class="style_copyIcon__w3b6v"></div></div></div></div></div><div class="MarkDown_scroller_wrapper__sPX_f"><div class="MarkDown_code_block_scroller__mJfhR md_code_block_scroller"><div turnid="f3abf2af-a35d-4a70-ac94-42813eefb46b" sentenceid="4dfcc37c-b339-4bc8-9fb3-eb54fcc06a28" extrainfo="[object Object]" data-sourcepos="53:1-65:6" sourceposition="[object Object]"><code class="language-cpp"><span></span>classSingleton {<span>  
</span><span></span><span>public</span><span>:  
</span><span></span>static Singleton& GetInstance()<span>{  
</span><span></span><span>static</span><span> Singleton instance;  </span><span>// 局部静态变量，线程安全初始化  </span><span>
</span><span></span><span>return</span><span> instance;  
</span>          }  
<span></span><span>private</span><span>:  
</span><span></span><span>Singleton</span><span>() = </span><span>default</span><span>;  
</span><span></span><span>Singleton</span><span>(</span><span>const</span><span> Singleton&) = </span><span>delete</span><span>;  
</span><span>          Singleton& </span><span>operator</span><span>=(</span><span>const</span><span> Singleton&) = </span><span>delete</span><span>;  
</span>      };  </code></div></div></div></div></pre>

#### **6. 多态（静态/动态）的机理实现**

* **静态多态（编译期）** ：
* **实现** ：函数重载（同一作用域函数名相同，参数不同）、模板特化（如 `std::vector<int>`/`std::vector<double>`）。
* **原理** ：编译器通过参数类型推导确定调用函数，无运行时开销。
* **动态多态（运行期）** ：
* **实现** ：虚函数 + 继承，派生类重写基类虚函数。
* **原理** ：
  * 基类包含 **虚函数表（vtable）** ，存储虚函数地址；
  * 对象包含 **虚表指针（vptr）** ，指向对应类的 vtable；
  * 通过基类指针调用时，根据 vptr 动态查找派生类实现（迟绑定）。

#### **7. 虚函数**

* **定义** ：基类中用 `virtual` 声明的函数，允许派生类重写（`override` 关键字显式标记）。
* **底层** ：
* 虚函数表（vtable）：每个包含虚函数的类有一个全局 vtable，按声明顺序存储虚函数地址。
* 虚表指针（vptr）：对象内存布局的首个成员（32位4字节，64位8字节），指向类的 vtable。
* **注意** ：构造函数不能是虚函数（对象未完全构造，vptr 未初始化），析构函数通常声明为虚函数（避免基类指针删除派生类对象时内存泄漏）。

#### **8. STL 容器分类与特性**

* **序列式容器** ：
* `vector<T>`：动态数组，随机访问 O(1)，尾部增删 O(1)（均摊），中间增删 O(n)。
* `list<T>`：双向链表，不支持随机访问，任意位置增删 O(1)。
* `deque<T>`：双端队列，头部/尾部增删 O(1)，适合频繁两头操作。
* **关联式容器** ：
* **有序** ：`map<K,V>`/`set<T>`（红黑树实现，O(log n) 增删查）。
* **无序** ：`unordered_map<K,V>`/`unordered_set<T>`（哈希表实现，平均 O(1) 增删查，冲突时链地址法）。
* **容器适配器** ：`stack<T>`（栈，底层 `deque`）、`queue<T>`（队列，底层 `deque`）、`priority_queue<T>`（堆，底层 `vector`）。

#### **9. 手撕题：二分法查找（非递归实现）**

<pre data-sourcepos="103:1-119:6"><div data-sentry-component="CustomCode" data-sentry-source-file="index.tsx"><div class="MarkDown_block_header__Jpkhb"><div class="MarkDown_language__DItCk">Cpp</div><div><div class="MarkDown_copyBtn__6Wmrp" data-sentry-component="CopyBtn" data-sentry-source-file="index.tsx"><div class="style_container__s7Iv8" aria-describedby=":raq:"><div class="style_copyIcon__w3b6v"></div></div></div></div></div><div class="MarkDown_scroller_wrapper__sPX_f"><div class="MarkDown_code_block_scroller__mJfhR md_code_block_scroller"><div turnid="f3abf2af-a35d-4a70-ac94-42813eefb46b" sentenceid="4dfcc37c-b339-4bc8-9fb3-eb54fcc06a28" extrainfo="[object Object]" data-sourcepos="103:1-119:6" sourceposition="[object Object]"><code class="language-cpp"><span>#</span>include<span></span><span><vector></span><span></span><span>
</span><span></span>intbinarySearch(const std::vector<int>& nums, int target)<span>{  
</span><span></span><span>int</span><span> left = </span><span>0</span><span>, right = nums.</span><span>size</span><span>() - </span><span>1</span><span>;  
</span><span></span><span>while</span><span> (left <= right) {  
</span><span></span><span>int</span><span> mid = left + (right - left) / </span><span>2</span><span>;  </span><span>// 避免溢出  </span><span>
</span><span></span><span>if</span><span> (nums[mid] == target) {  
</span><span></span><span>return</span><span> mid;  
</span><span>        } </span><span>else</span><span></span><span>if</span><span> (nums[mid] < target) {  
</span><span>            left = mid + </span><span>1</span><span>;  
</span><span>        } </span><span>else</span><span> {  
</span><span>            right = mid - </span><span>1</span><span>;  
</span>        }  
    }  
<span></span><span>return</span><span></span><span>-1</span><span>;  </span><span>// 未找到  </span><span>
</span>}  </code></div></div></div></div></pre>

* **时间复杂度** ：O(log n)， **空间复杂度** ：O(1)。
* **边界条件** ：需处理空数组、target 在首尾、不存在 target 等情况。

### **自动驾驶场景相关性**

* **线程同步** ：传感器数据（激光雷达/摄像头）的多线程读写需锁或原子操作。
* **单例模式** ：全局配置管理、日志系统等模块需保证唯一实例。
* **容器选择** ：高频访问的地图数据可用 `unordered_map`（O(1) 查找），时序数据队列可用 `deque`。

以上内容覆盖核心知识点，可结合自动驾驶实际场景（如多传感器融合、实时数据处理）展开细节。

### 多继承的问题及解决方案

#### **一、多继承的问题**

1. **菱形继承**
   * 当一个派生类间接继承自同一个基类时（如 D 继承 B 和 C，而 B、C 均继承 A），会导致共同基类（A）在派生类（D）中存在多份实例，造成数据冗余和二义性。
2. **多个基类有同名成员（成员名冲突）**
   * 不同基类中若存在同名的成员变量或成员函数，派生类访问时会产生歧义，编译器无法确定调用哪个基类的成员。
3. **类层次结构混乱，维护难度增加**
   * 多继承会使类之间的关系变得复杂，层次结构不清晰，增加代码阅读和维护的难度。

#### **二、解决方案**

1. **虚继承**
   * **作用** ：确保共同基类在派生类中只保留一份实例，解决菱形继承的数据冗余和二义性。
   * **实现** ：中间基类（如 B、C）通过 `virtual` 关键字继承共同基类（A），最终派生类（D）直接构造共同基类，忽略中间类的构造函数。
   * **示例** ：

<pre data-sourcepos="20:1-25:6"><div data-sentry-component="CustomCode" data-sentry-source-file="index.tsx"><div class="MarkDown_block_header__Jpkhb"><div class="MarkDown_language__DItCk">Cpp</div><div><div class="MarkDown_copyBtn__6Wmrp" data-sentry-component="CopyBtn" data-sentry-source-file="index.tsx"><div class="style_container__s7Iv8" aria-describedby=":rak:"><div class="style_copyIcon__w3b6v"></div></div></div></div></div><div class="MarkDown_scroller_wrapper__sPX_f"><div class="MarkDown_code_block_scroller__mJfhR md_code_block_scroller"><div turnid="dd9461f1-a729-46f5-a8f6-0a6183e733e1" sentenceid="677dd24e-ccbe-4067-a89f-4a8bbef15603" extrainfo="[object Object]" data-sourcepos="20:1-25:6" sourceposition="[object Object]"><code class="language-cpp"><span></span>classA {<span>};
</span><span></span>classB :<span></span><span>virtual</span><span></span><span>public</span><span> A {};  </span><span>// 虚继承 A</span><span>
</span><span></span>classC :<span></span><span>virtual</span><span></span><span>public</span><span> A {};  </span><span>// 虚继承 A</span><span>
</span><span></span>classD :<span></span><span>public</span><span> B, </span><span>public</span><span> C {};  </span><span>// D 中只包含一份 A 的实例</span></code></div></div></div></div></pre>

2. **通过作用域运算符解决成员名冲突**
   * 当派生类访问同名成员时，显式指定基类作用域（如 `Base::member`），消除二义性。
3. **使用组合代替继承**
   * 通过在类中包含其他类的对象（组合），而非继承其接口，降低类之间的耦合，避免多继承的复杂度。
4. **使用接口（纯虚函数）定义抽象行为**
   * 将基类设计为只包含纯虚函数的接口，派生类实现接口中的函数，避免继承实现细节，减少多继承中的实现冗余。

#### **三、示例代码对比**

* **普通多继承（菱形问题）** ：

<pre data-sourcepos="39:1-44:6"><div data-sentry-component="CustomCode" data-sentry-source-file="index.tsx"><div class="MarkDown_block_header__Jpkhb"><div class="MarkDown_language__DItCk">Cpp</div><div><div class="MarkDown_copyBtn__6Wmrp" data-sentry-component="CopyBtn" data-sentry-source-file="index.tsx"><div class="style_container__s7Iv8" aria-describedby=":ram:"><div class="style_copyIcon__w3b6v"></div></div></div></div></div><div class="MarkDown_scroller_wrapper__sPX_f"><div class="MarkDown_code_block_scroller__mJfhR md_code_block_scroller"><div turnid="dd9461f1-a729-46f5-a8f6-0a6183e733e1" sentenceid="677dd24e-ccbe-4067-a89f-4a8bbef15603" extrainfo="[object Object]" data-sourcepos="39:1-44:6" sourceposition="[object Object]"><code class="language-cpp"><span></span>classA {<span>};
</span><span></span>classB :<span></span><span>public</span><span> A {};  </span><span>// B 继承 A</span><span>
</span><span></span>classC :<span></span><span>public</span><span> A {};  </span><span>// C 继承 A</span><span>
</span><span></span>classD :<span></span><span>public</span><span> B, </span><span>public</span><span> C {};  </span><span>// D 包含两份 A 的实例（B::A 和 C::A）</span></code></div></div></div></div></pre>

* **虚继承解决菱形问题** ：

<pre data-sourcepos="47:1-52:4"><div data-sentry-component="CustomCode" data-sentry-source-file="index.tsx"><div class="MarkDown_block_header__Jpkhb"><div class="MarkDown_language__DItCk">Cpp</div><div><div class="MarkDown_copyBtn__6Wmrp" data-sentry-component="CopyBtn" data-sentry-source-file="index.tsx"><div class="style_container__s7Iv8" aria-describedby=":rao:"><div class="style_copyIcon__w3b6v"></div></div></div></div></div><div class="MarkDown_scroller_wrapper__sPX_f"><div class="MarkDown_code_block_scroller__mJfhR md_code_block_scroller"><div turnid="dd9461f1-a729-46f5-a8f6-0a6183e733e1" sentenceid="677dd24e-ccbe-4067-a89f-4a8bbef15603" extrainfo="[object Object]" data-sourcepos="47:1-52:4" sourceposition="[object Object]"><code class="language-cpp"><span></span>classA {<span>};
</span><span></span>classB :<span></span><span>virtual</span><span></span><span>public</span><span> A {};  </span><span>// 虚继承 A</span><span>
</span><span></span>classC :<span></span><span>virtual</span><span></span><span>public</span><span> A {};  </span><span>// 虚继承 A</span><span>
</span><span></span>classD :<span></span><span>public</span><span> B, </span><span>public</span><span> C {};  </span><span>// D 中只包含一份 A 的实例</span></code></div></div></div></div></pre>
