# 多乐游戏

1.自我介绍

2.mysql和redis区别 应用区别（不熟）


* MySQL：关系型数据库（磁盘持久化、支持 SQL、事务、复杂查询）。
* Redis：内存键值存储（超低延迟、丰富数据结构，可选持久化，适合缓存和实时场景）。

数据模型与操作

* MySQL：表/行/列，支持 JOIN、事务、复杂筛选。
* Redis：键 → 值，值可为 string、hash、list、set、zset 等，操作原子且高效。

性能与延迟

* MySQL：磁盘为主，读写延迟较高但能存大数据、保证 ACID。
* Redis：内存为主，读写非常快（ms 以下），适合热点数据和频繁访问场景。

持久化与可靠性

* MySQL：默认持久化（更强的一致性和恢复能力）。
* Redis：内存优先，支持 RDB/AOF 持久化，但默认耐久性不如 MySQL；受内存限制。

典型应用

* MySQL：用户资料、订单、财务、业务主数据、复杂报表。
* Redis：缓存（session、热点数据）、分布式锁、计数器、排行榜、消息队列、短期会话数据。

常见结合模式（推荐初学者记住）

* Cache-aside（常用）：读取时先查 Redis，未命中再查 MySQL 并回写 Redis；写入先更新 MySQL，再删除/更新 Redis。
* 两者配合能兼顾持久性与性能

3.事务的概念 (不熟)

* 事务（Transaction）是一组作为单个工作单元执行的数据库操作，要么全部成功提交，要么全部撤销回滚，保证数据一致性。

ACID 四要素

* 原子性（Atomicity）：要么全部执行，要么全部不执行。
* 一致性（Consistency）：事务执行前后，数据满足所有规则/约束。
* 隔离性（Isolation）：并发事务之间互不干扰（隔离级别不同影响并发现象）。
* 持久性（Durability）：事务提交后，对数据的修改永久保存（即使宕机也能恢复）

4. **输出是** **(null)** **或者** **段错误/访问冲突（答错）**

```c++
void getmemory(char **p) // 接收指向指针的指针
{
    *p = new char[100]; // 解引用 p，修改 main 函数中 p 指向的内存
    strcpy(*p, "hello world");
    // 不需要 return，因为 *p 已经被修改
}

int main()
{
    char *p = NULL;
    getmemory(&p); // 传递 p 的地址
    printf("%s\n", p);
    delete[] p; // 记得释放内存
    return 0;
}
```

5.class a

---

```c++
















&class A {
public:
    A() {} // 类 A 的默认构造函数

    virtual void show() // 虚函数 show()
    {
        printf("class A\n"); // 打印 "class A"
    }
};

class B : public A { // 类 B 公有继承自类 A
public:
    B() {} // 类 B 的默认构造函数

    virtual void show() // 虚函数 show()，覆盖了基类 A 的 show()
    {
        // ... (图片被截断了，这里是 B::show() 的实现部分)
        // 假设这里会打印 "class B"
        // printf("class B\n");
    }
};#include <cstdio> // 为了使用 printf

class A {
public:
    A() {}

    virtual void show()
    {
        printf("class A\n");
    }
};

class B : public A {
public:
    B() {}

    virtual void show() // 覆盖基类 A 的 show()
    {
        printf("class B\n");
    }
};

void func(A a) // 注意：这里参数是 A a (按值传递)
{
    a.show();
}

int main()
{
    B b;         // 创建一个 B 类型的对象
    func(b);     // 将 B 类型的对象 b 传递给 func
    return 0;
}
```

6.值传递引用传递区别

7.进程通信方式

8.socket通信中讲一下字节序的概念大小端

union A {
    int a;
    char c;
};

A aa;
aa.c = 1;

void func(char str_arg[100]) // 这里的 char str_arg[100] 实际上是 char* str_arg
{
    // 第一个输出
    std::cout << sizeof(str_arg) << std::endl;
}

int main(int argc, char* argv[])
{
    char str[] = "Hello"; // 字符数组，包含 "Hello" 和一个空终止符 '\0'
    char *p = str;        // 指针 p 指向字符数组 str 的第一个元素

    // 第二个输出
    std::cout << sizeof(str) << std::endl;

    // 第三个输出
    std::cout << sizeof(p) << std::endl;

    func("test"); // 调用 func 函数，传入字符串字面量 "test"

    return0;
}

11.发送端向接收端发送一个int32数字使用tcpip编程怎么处理

// 发送端
char* buffer = "102400"; // buffer 指向字符串字面量
send(fd, buffer, strlen(buffer)); // 发送 buffer 指向的字符串内容，长度由 strlen() 确定

// 接收端
char buffer_recv[64] = {0}; // 声明一个字符数组用于接收
recv(fd, buffer_recv, 64); // 接收数据到 buffer_recv，最多接收 64 字节
int n = atoi(buffer_recv); // 将接收到的字符串转换为整数

// 发送端
int n_send = 102400; // 声明一个整数变量
send(fd, &n_send, sizeof(int)); // 发送整数 n 的内存地址，长度是 int 类型的大小

// 接收端
int n_recv; // 声明一个整数变量用于接收
recv(fd, &n_recv, sizeof(int)); // 接收数据到 n 的内存地址，长度是 int 类型的大小
