# 顽岩资产

### 一面

**inline 有什么用处？**

`inline` 关键字的主要用途是向编译器建议将函数内联展开，即在调用处直接插入函数体代码，而不是进行常规的函数调用。这可以：

1. 减少函数调用的开销（压栈、跳转等）
2. 可能提高程序执行效率（特别是对小函数）
3. 但可能增加代码体积

**inline 和普通函数有啥区别？**

1. 编译行为不同：inline 函数可能在调用处展开，普通函数总是通过调用实现
2. 定义要求：inline 函数通常需要在头文件中定义，普通函数通常在源文件中定义
3. ODR规则：inline 函数可以跨编译单元重复定义（链接时会合并），普通函数不行

**Cpp 新功能？**

C++11/14/17/20 引入了许多新特性，例如：

C++11: auto, lambda, 智能指针, range-based for, 移动语义

C++14: 泛型 lambda, 变量模   板, 二进制字面量

C++17: 结构化绑定, std::optional, 并行算法

C++20: 概念(concepts), 协程, ranges 库, 模块(modules)

**用过模板吗？**

模板是 C++ 的泛型编程机制，包括：

函数模板

类模板

可变参数模板

模板特化和偏特化

C++20 的概念约束模板

**有多线程编程经历吗？**

* 使用 std::thread, std::async
* 同步原语：mutex, condition_variable, atomic
* 线程池实现
* 无锁编程
* 基础并发数据结构和算法

**C/Cpp 怎么创建线程？**

C (POSIX Threads): 在 Linux/macOS 等类 Unix 系统中，通常使用 pthreads 库。
核心函数: pthread_create()。
需要包含头文件 <pthread.h> 并链接 -lpthread 库。
C++ (C++11 及以后): C++11 标准库提供了面向对象的线程支持。
核心类: std::thread。
需要包含头文件 `<thread>`。
示例: std::thread my_thread(function_name, arg1, arg2);

**malloc/new 有啥区别？**

| **特性**      | **malloc** **/** **free**                      | **new** **/** **delete**                                          |
| ------------------- | ---------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **来源**      | **C 标准库函数**                                           | **C++ 操作符**                                                                |
| **类型安全**  | **返回** **void***，需要手动强制类型转换，非类型安全 | **返回具体类型的指针，类型安全**                                              |
| **构造/析构** | **仅分配/释放内存，不调用对象的构造和析构函数**            | **分配内存后调用构造函数，释放内存前调用析构函数**                            |
| **失败处理**  | **失败时返回** **NULL**                              | **默认情况下，失败时抛出** **std::bad_alloc** **异常**            |
| **重载**      | **不可重载**                                               | **可以被重载，以实现自定义内存分配策略**                                      |
| **数组处理**  | **需要手动计算数组总字节大小**                             | **使用** **new[]** **和** **delete[]** **来处理数组** |

**为什么选量化？**

对金融和算法都有浓厚兴趣
喜欢将数学和编程结合解决实际问题
享受高性能和低延迟的挑战
量化领域需要持续学习和创新
能够发挥在算法优化和系统编程方面的优势

**coding 实现一个 latency 的平均值和标准差统计，需要多线程吗（先不用），但是要求 on-line（新增和过期时）地更新**

# 二面

**编译流程？**

1. **预处理** ：处理宏、头文件展开、条件编译等，生成 `.i`文件（`gcc -E`）。
2. **编译** ：将预处理后的代码转换为汇编代码（`.s`文件），进行语法和语义分析（`gcc -S`）。
3. **汇编** ：将汇编代码转为机器码（`.o`目标文件，`gcc -c`）。
4. **链接** ：合并目标文件和库文件，解析符号引用，生成可执行文件（`gcc -o`）

**lambda 传值方式、缺点？**

1. **传值方式**
   * **捕获列表** ：
   * `[=]`：隐式值捕获（可能引发悬挂指针）。
   * `[x]`：显式值捕获变量 `x`。
   * `[this]`：捕获当前类指针（需注意对象生命周期）。
   * **引用捕获** ：`[&x]`或 `[&]`（需确保被引用的对象存活）。
2. **缺点**
   * 值捕获可能拷贝大对象（性能开销）。
   * 引用捕获易导致悬挂引用（如lambda异步执行时局部变量已销毁）。
   * 隐式捕获（`[=]`/`[&]`）可能意外捕获不需要的变量

**多线程了解吗？**

1. **线程同步**
   * **互斥锁（`std::mutex`）** ：避免数据竞争，需配合 `lock_guard`/`unique_lock`。
   * **条件变量（`std::condition_variable`）** ：线程间通信，需搭配互斥锁使用。
2. **原子操作**
   * `std::atomic`保证操作的原子性（如 `atomic<int>`）。
3. **异步编程**
   * `std::async`、`std::future`实现异步任务。
4. **问题**
   * 死锁（避免方式：按固定顺序加锁、RAII管理锁）。
   * 虚假唤醒（条件变量需用循环检查条件）

**金融知识了解多少？**

**有做过金融项目吗？**

**场景题**

10w x 10w 的矩阵，并发访问（QPS 不大），如何建立线程模型？

1. **存储优化**
   * **稀疏矩阵存储** （如 CSR/CSC 格式）：
   * 仅存储非零元素，节省空间。
   * 适用于大部分元素为0的场景（如推荐系统、图计算）。
   * **分块存储（Blocking）** ：
   * 将矩阵划分为多个子矩阵（如 1000×1000），存储在不同机器/磁盘。
   * 按需加载部分数据到内存（类似数据库分页）。
2. **线程模型**
   * **读写锁（Read-Write Lock）** ：
   * 多个线程可同时读，写线程独占访问。
   * 适用于读多写少的场景（QPS 不高时适用）。
   * **细粒度锁（Fine-grained Locking）** ：
   * 对矩阵分块，每个块单独加锁（减少锁竞争）。
   * 例如：`std::shared_mutex` 或 `tbb::concurrent_hash_map`（Intel TBB）。
   * **无锁数据结构（Lock-free）** ：
   * 使用原子操作（CAS）实现并发访问（适用于高性能场景）。
   * 例如：`std::atomic` 或 `folly::AtomicHashMap`（Facebook Folly）。
3. **分布式方案（可选）**
   * **分布式计算框架** （如 Spark、Dask）：
   * 矩阵分片存储在不同节点，并行计算。
   * **内存数据库** （如 Redis Cluster）：
   * 使用 `Redis` 存储矩阵，支持并发访问

一个 core dump 的程序，如何 debug？

如何定位并解决运行慢的问题？

* **空指针解引用** （`Segmentation fault`）。
* **数组越界** （`heap corruption`）。
* **多线程竞争** （如 `double free`）。
* **未初始化变量** （`undefined behavior`）

给定一段时间的电梯运行和人流量数据，建立根据电梯行为进行人流量预测的模型。

大文件小内存求 unique 数量

* **精确去重** → 外部排序 + 归并。
* **低内存消耗** → HyperLogLog（近似）。
* **高性能** → 哈希分片 + 并行处理

# 线下终面

**一轮**

static

inline

move 和 vector 拷贝构造移动构造，`A a = f()` vs `A a; a = f();`

vector 扩容机制

堆栈区别，优劣

array 怎么弄在堆上

linux 死机 debug

怎么判断系统是大端还是小端

多线程、含参初始化 的 单例 的 实现：static 函数 + 计数器 + 指针

实现 `vector<A>`的多线程析构

**二轮**

算法题

实现 itos，要求尽可能快

n 个数 m 个划分，使 minmax 差值最小

**三轮**

工程题

- csv parser
- 斗地主模拟器

**四轮**

hr面

💻 语言 & 基础
除了C++，你还熟悉哪些编程语言？做工程时如何选型？
mmap是什么？它和共享内存有什么关系？
多线程编程中，你用过哪些并发结构？
如何检测和避免死锁？
RAII机制是什么？它在C++中如何应用？
什么是优先队列？它的底层实现是什么？
C++的动态多态是如何实现的？
成员函数后面加const的作用是什么？
父类指针如何安全地转换为子类指针？

🔍 STL 容器与内存管理
vector在push_back时容量满了会发生什么？如何优化频繁插入的场景？
reserve和resize有什么区别？
map和unordered_map的底层实现及适用场景是什么？
如何获取vector的当前容量？如何提前分配空间？

🚀 Redis & 数据库
Redis支持哪些数据结构？Zset的底层实现原理？
SQL中的JOIN有哪几种？有什么区别？

🌐 网络编程
TCP/IP模型分为哪几层？网络层有哪些常见协议？
ARP协议的作用是什么？
epoll有哪几种模式？边缘触发（ET）和水平触发（LT）有什么区别？
UDP协议的特点是什么？适合哪些场景？

💡 算法 & 调试
手撕代码：反转链表 + 快排
你平时如何调试代码？有哪些调试技巧？





1 c++构造函数和析构函数可不可以是虚函数和原因

 **构造函数** ：

* 不能是虚函数
* 原因：
  * 对象在构造时还没有完整的虚函数表(vtable)
  * 构造函数调用时对象类型是明确的，不需要动态绑定
  * 虚函数机制依赖于对象已经构造完成

 **析构函数** ：

* 基类的析构函数应该是虚函数
* 原因：
  * 当通过基类指针删除派生类对象时，如果不是虚函数，只会调用基类析构函数，导致派生类部分内存泄漏
  * 虚析构函数确保正确调用整个对象继承链上的析构函数

2 虚函数表地址怎么获取


3 智能指针

++智能指针是管理动态内存的类模板，位于 `<memory>`头文件中，主要类型：

* `unique_ptr`: 独占所有权指针
* `shared_ptr`: 共享所有权指针
* `weak_ptr`: 不控制对象生命周期的弱引用指针

优点：

* 自动内存管理，防止内存泄漏
* 异常安全
* 明确所有权语义

4 sharedptr

`shared_ptr`实现共享所有权的智能指针：

* 使用引用计数跟踪资源
* 当最后一个 `shared_ptr`销毁时释放资源
* 支持自定义删除器
* 线程安全的引用计数增减操作

潜在问题：

* 循环引用（需配合 `weak_ptr`解决）
* 性能开销（引用计数操作）

5 协程和线程区别

特性	线程	协程
调度方式	由OS内核调度	用户态程序自己调度
切换开销	较大（上下文切换）	很小（仅寄存器保存）
并发性	真正并行	协作式单线程内并发
内存占用	较大（MB级栈）	很小（KB级栈）
通信方式	需要同步机制	直接共享变量

6 stl unorder_map 和map区别

7 解决哈希冲突方法


开放寻址法：

线性探测
二次探测
双重哈希
链地址法：

每个桶使用链表存储冲突元素
STL的unordered_map采用此法
再哈希法：

使用第二个哈希函数计算新位置
建立公共溢出区：

将冲突元素放入单独区域

8 其它的哈希表

9 vevtor的push和emplace区别


不一定，取决于具体情况：

更高效：当构造参数较多或对象构造代价高时
无差别：当传递已构造对象且移动构造代价低时
可能更低效：当参数需要隐式转换时可能产生临时对象

10 emplace_back一定会更高效吗

11 移动构造函数是做什么的

区别：

资源分配：

进程：独立地址空间和系统资源
线程：共享进程资源，有独立栈和寄存器
通信方式：

进程：管道、消息队列、共享内存等
线程：直接读写共享内存
稳定性：

进程：一个崩溃不影响其他进程
线程：一个崩溃可能导致整个进程崩溃
创建速度：

线程创建比进程快得多
原因：
线程共享已有地址空间
不需要创建新的内存映射和资源表
仅需分配栈和设置寄存器状态

12 线程和进程区别 创建线程比进程快吗？

基本假设	冲突很可能发生	冲突很少发生
实现方式	加锁(mutex等)	版本号/时间戳比较
阻塞	会阻塞其他线程	不阻塞，但可能重试
适用场景	写操作多，冲突概率高	读多写少，冲突概率低
开销	上下文切换和调度开销	冲突时重试开销

13 悲观锁和乐观锁区别

14 原子操作底层实现 `<atomic>`底层实现

原子操作的实现方式：

硬件支持：

CPU提供的原子指令(如x86的LOCK前缀指令)
CAS(Compare-And-Swap)指令
LL/SC(Load-Linked/Store-Conditional)指令
编译器支持：

禁止指令重排
生成适当的内存屏障指令
软件回退：

在不支持硬件原子操作的平台上使用锁模拟



15 CAS用处


CAS(Compare-And-Swap)用途：

实现无锁数据结构
原子计数器
线程安全标志位
实现自旋锁
乐观锁实现

16 thread_local关键字


CAS(Compare-And-Swap)用途：

实现无锁数据结构
原子计数器
线程安全标志位
实现自旋锁
乐观锁实现

17 右值和左指区别

18 c++编译层面的优化


常见编译优化：

内联展开：将小函数调用替换为函数体
常量传播：替换已知常量值
死代码消除：移除不可达代码
循环优化：展开、向量化、并行化
返回值优化(RVO/NRVO)：消除临时对象
尾调用优化：重用调用栈帧
公共子表达式消除：避免重复计算

19 lamba表达式和函数指针谁性能高


般情况下：

* **lambda表达式**可能更高效，因为：
  * 可被编译器内联
  * 无间接调用开销
  * 可捕获上下文，避免额外参数传递
* **函数指针** ：
* 通常无法内联
* 有间接调用开销
* 但接口更通用



20 多路复用简单介绍 select和epoll epoll有几个接口  epoll管理使用什么数据结构

**多路复用** ：一种I/O模型，允许单线程监控多个文件描述符。

 **select** ：

* 跨平台但效率低
* 线性扫描所有fd
* 最大fd数量有限制(FD_SETSIZE)
* 每次调用需重置fd_set

 **epoll** (Linux特有)：

* 更高效的事件通知机制
* 使用红黑树管理fd
* 仅返回就绪的fd
* 无fd数量硬限制

 **epoll接口** ：

1. `epoll_create()`: 创建epoll实例
2. `epoll_ctl()`: 添加/修改/删除监控fd
3. `epoll_wait()`: 等待I/O事件

 **epoll数据结构** ：

* 使用红黑树存储所有监控的fd
* 就绪列表使用双向链表
