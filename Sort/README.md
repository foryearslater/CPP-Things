| **排序算法** | **平均时间复杂度**      | **最坏时间复杂度** | **空间复杂度** | **稳定性** |
| ------------------ | ----------------------------- | ------------------------ | -------------------- | ---------------- |
| **冒泡排序** | **O(n²)**              | **O(n²)**         | **O(1)**       | **稳定**   |
| **选择排序** | **O(n²)**              | **O(n²)**         | **O(1)**       | **不稳定** |
| **插入排序** | **O(n²)**              | **O(n²)**         | **O(1)**       | **稳定**   |
| **希尔排序** | **O(n log n) ~ O(n²)** | **O(n²)**         | **O(1)**       | **不稳定** |
| **归并排序** | **O(n log n)**          | **O(n log n)**     | **O(n)**       | **稳定**   |
| **快速排序** | **O(n log n)**          | **O(n²)**         | **O(log n)**   | **不稳定** |
| **堆排序**   | **O(n log n)**          | **O(n log n)**     | **O(1)**       | **不稳定** |
| **计数排序** | **O(n + k)**            | **O(n + k)**       | **O(k)**       | **稳定**   |
| **桶排序**   | **O(n + k)**            | **O(n²)**         | **O(n + k)**   | **稳定**   |
| **基数排序** | **O(d(n + k))**         | **O(d(n + k))**    | **O(n + k)**   | **稳定**   |

### **1. 冒泡排序 (Bubble Sort)**

 **原理** ：

* 重复遍历数组，比较相邻元素，若顺序错误则交换。
* 每轮遍历将最大（或最小）元素“冒泡”到末尾。  **步骤** ：

1. 从第一个元素开始，比较相邻元素。
2. 若 `arr[j] > arr[j+1]`，交换它们。
3. 每轮遍历后，末尾元素已排序。
4. 重复直到无交换发生。  **时间复杂度** ：

* 最好：O(n)（已有序）
* 平均/最坏：O(n²)  **空间复杂度** ：O(1)  **稳定性** ：稳定（相等元素不交换）。

### **2. 选择排序 (Selection Sort)**

 **原理** ：

* 从未排序部分选出最小元素，与未排序部分首位交换。  **步骤** ：

1. 在 `arr[i...n-1]` 中找最小元素的下标 `min_idx`。
2. 交换 `arr[i]` 与 `arr[min_idx]`。
3. 重复直到全部有序。  **时间复杂度** ：O(n²)（始终需比较所有元素）  **空间复杂度** ：O(1)  **稳定性** ：不稳定（交换可能改变相等元素顺序）。

### **3. 插入排序 (Insertion Sort)**

 **原理** ：

* 将数组分为已排序和未排序两部分，逐个将未排序元素插入已排序部分的正确位置。  **步骤** ：

1. 从 `i=1` 开始，将 `arr[i]` 与已排序部分 `arr[0...i-1]` 比较。
2. 若 `arr[j] > key`（`key=arr[i]`），将元素后移。
3. 插入 `key` 到正确位置。  **时间复杂度** ：

* 最好：O(n)（已有序）
* 平均/最坏：O(n²)  **空间复杂度** ：O(1)  **稳定性** ：稳定（元素逐个前移，不改变相等元素顺序）。

### **4. 希尔排序 (Shell Sort)**

 **原理** ：

* 改进插入排序，允许远距离元素交换。按增量序列分组，每组插入排序，逐步缩小增量至1。  **步骤** ：

1. 选择增量序列（如 `gap = n/2, n/4, ..., 1`）。
2. 对每个增量 `gap`，将数组分为 `gap` 组，每组插入排序。
3. 最后 `gap=1` 时全数组插入排序。  **时间复杂度** ：O(n log n) ~ O(n²)（取决于增量序列）  **空间复杂度** ：O(1)  **稳定性** ：不稳定（分组可能破坏相等元素顺序）。

### **5. 归并排序 (Merge Sort)**

 **原理** ：

* 分治法：递归地将数组分成两半，排序后合并两个有序数组。  **步骤** ：

1. **分** ：递归将数组二分至单个元素。
2. **治** ：合并两个有序子数组：

* 比较两个子数组的首元素，取较小者放入合并数组。
* 重复直到一个子数组为空，将另一子数组剩余元素追加。  **时间复杂度** ：O(n log n)（所有情况）  **空间复杂度** ：O(n)（合并需额外数组）  **稳定性** ：稳定（合并时优先取左子数组元素）。

### **6. 快速排序 (Quick Sort)**

 **原理** ：

* 分治法：选基准（pivot），将小于基准的元素放左侧，大于的放右侧，递归处理左右子数组。  **步骤** ：

1. 选基准（如首位、末位或随机）。
2. **分区** ：

* 双指针 `i`（左）、`j`（右）向中间扫描。
* 交换逆序对（`arr[i] > pivot` 且 `arr[j] < pivot`）。
* 最终将基准放入正确位置。

1. 递归排序左右子数组。  **时间复杂度** ：

* 最好/平均：O(n log n)
* 最坏：O(n²)（数组已有序且基准选首位）  **空间复杂度** ：O(log n)（递归栈）  **稳定性** ：不稳定（分区交换破坏顺序）。

### **7. 堆排序 (Heap Sort)**

 **原理** ：

* 利用 **最大堆** （父节点 ≥ 子节点）的特性。  **步骤** ：

1. **建堆** ：从最后一个非叶节点开始，自底向上调整成最大堆。
2. **排序** ：

* 交换堆顶（最大值）与末尾元素。
* 堆大小减一，重新调整堆（Heapify）。
* 重复直到堆为空。  **时间复杂度** ：O(n log n)（所有情况）  **空间复杂度** ：O(1)（原地排序）  **稳定性** ：不稳定（堆调整可能改变顺序）。

### **8. 计数排序 (Counting Sort)**

 **原理** ：

* 非比较排序，适用于整数且范围较小的数据。统计每个元素出现次数，计算前缀和确定位置。  **步骤** ：

1. 统计元素频率到计数数组 `count[]`。
2. 计算前缀和：`count[i] += count[i-1]`（表示 ≤ `i` 的元素个数）。
3. 反向遍历原数组，按 `count[arr[i]]` 的值将元素放入输出数组对应位置。  **时间复杂度** ：O(n + k)（`k` 为数值范围）  **空间复杂度** ：O(n + k)  **稳定性** ：稳定（反向遍历保证相同元素顺序不变）。

### **9. 桶排序 (Bucket Sort)**

 **原理** ：

* 将数据分到有限数量的桶中，每个桶单独排序（通常用插入排序），最后合并。  **步骤** ：

1. 根据范围创建 `k` 个桶（如 `[0,10), [10,20), ...`）。
2. 将元素分配到对应桶中。
3. 对每个非空桶排序。
4. 按桶顺序合并结果。  **时间复杂度** ：

* 最好：O(n)（均匀分布）
* 最坏：O(n²)（所有元素集中一个桶）  **空间复杂度** ：O(n + k)  **稳定性** ：稳定（取决于桶内排序算法的稳定性）。

### **10. 基数排序 (Radix Sort)**

 **原理** ：

* 按位数排序：从低位到高位（或反之），每次用稳定排序（如计数排序）处理一位。  **步骤** ：

1. 找出最大数，确定最大位数 `d`。
2. 从最低位开始，对每一位进行稳定排序（如计数排序）。
3. 重复直到最高位排序完成。  **时间复杂度** ：O(d · (n + k))（`d` 为最大位数，`k` 为基数，如10进制中 `k=10`）  **空间复杂度** ：O(n + k)  **稳定性** ：稳定（依赖底层排序的稳定性）。

## **11.内省排序**（**IntroSort)**

* **快速排序 (QuickSort)：**

  * **优点：** **在**平均情况下**性能极佳，通常是 O(N log N) 并且常数因子很小，是实际应用中最快的通用排序算法之一。它是**原地排序**，空间复杂度低（O(log N) 递归栈空间）。**
  * **缺点：** **在**最坏情况下**（例如，输入数据已经部分有序或完全逆序，且基准选择不当），时间复杂度会退化到 O(N^2)。**
* **堆排序 (HeapSort)：**

  * **优点：** **能够保证在**所有情况下**都达到 O(N log N) 的时间复杂度，并且是**原地排序**（空间复杂度 O(1)）。**
  * **缺点：** **相比快速排序，其平均性能通常稍慢（常数因子较大）。**
* **插入排序 (InsertionSort)：**

  * **优点：** **对于**小规模数据**或**接近有序的数据**非常高效，时间复杂度为 O(N)（接近有序时），且常数因子非常小。实现简单。**
  * **缺点：** **对于大规模的随机数据，时间复杂度为 O(N^2)，效率很低。**

**内省排序的工作原理（如何结合）：**

**内省排序是“自省”的，它会根据排序过程中的情况动态选择最适合的算法：**

* **主要阶段：快速排序 (QuickSort)**

  * **内省排序首先使用快速排序作为主要算法。快速排序的平均性能最好，所以这是首选。**
* **应对最坏情况：切换到堆排序 (HeapSort)**

  * **为了避免快速排序 O(N^2) 的最坏情况，内省排序会监控快速排序的**递归深度**。**
  * **如果递归深度超过某个预设的**限制**（通常是** **2 * log2(N)**，其中 N 是原始数组的大小），这意味着快速排序在连续选择了不好的基准，导致分区不平衡，有退化到 O(N^2) 的风险。
  * **在这种情况下，内省排序会立即**切换**到堆排序。因为堆排序能保证 O(N log N) 的时间复杂度，所以即使快速排序表现不佳，整个内省排序算法的最坏时间复杂度依然是 O(N log N)。**
* **处理小规模子问题：切换到插入排序 (InsertionSort)**

  * **当快速排序递归到子数组的规模非常小（例如，元素数量小于 16 或 32）时，排序的**开销（函数调用、分区逻辑）**变得相对较大。**
  * **在这种情况下，内省排序会**切换**到插入排序。插入排序在处理小数组时具有极低的常数因子，表现往往优于快速排序和堆排序。这能显著提高整体效率。**

**总结其特点：**

* **时间复杂度：**

  * **最佳情况：** **O(N log N)**
  * **平均情况：** **O(N log N)**
  * **最坏情况：** **O(N log N) (通过切换到堆排序保证)**
* **空间复杂度：** **O(log N) (主要由快速排序的递归栈空间决定)**
* **稳定性：** **不稳定**。因为它内部使用的快速排序和堆排序都是不稳定的。如果需要稳定排序，应使用 **std::stable_sort** **(通常是归并排序的实现)。**
* **实际应用：**

  * **它是 C++ 标准库中** **std::sort** **函数的典型实现。**
  * **被认为是在实践中通用排序的最佳选择之一，因为它结合了高效的平均性能和强大的最坏情况性能保证。**
